package network

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// BridgeManager handles socket_vmnet bridge networking setup
type BridgeManager struct {
	brewPrefix string
}

// NewBridgeManager creates a new bridge network manager
func NewBridgeManager(brewPrefix string) *BridgeManager {
	return &BridgeManager{brewPrefix: brewPrefix}
}

// IsInstalled checks if socket_vmnet is installed
func (b *BridgeManager) IsInstalled() bool {
	cmd := exec.Command("brew", "list", "socket_vmnet")
	return cmd.Run() == nil
}

// IsRunning checks if socket_vmnet service is running
func (b *BridgeManager) IsRunning() bool {
	cmd := exec.Command("pgrep", "-f", "socket_vmnet")
	return cmd.Run() == nil
}

// IsReady checks if socket_vmnet is ready (running and socket available)
func (b *BridgeManager) IsReady() bool {
	if !b.IsRunning() {
		return false
	}

	socketPath := filepath.Join(b.brewPrefix, "var/run/socket_vmnet")
	_, err := os.Stat(socketPath)
	return err == nil
}

// Install installs socket_vmnet using Homebrew
func (b *BridgeManager) Install() error {
	fmt.Println("Installing socket_vmnet...")

	cmd := exec.Command("brew", "install", "socket_vmnet")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to install socket_vmnet: %w", err)
	}

	fmt.Println("✓ socket_vmnet installed")
	return nil
}

// Setup configures and starts socket_vmnet
func (b *BridgeManager) Setup() error {
	// Ensure socket_vmnet is installed
	if !b.IsInstalled() {
		if err := b.Install(); err != nil {
			return err
		}
	}

	// Detect primary network interface
	iface, err := b.detectPrimaryInterface()
	if err != nil {
		return fmt.Errorf("failed to detect network interface: %w", err)
	}

	fmt.Printf("Using network interface: %s\n", iface)

	// Warn if using WiFi
	if b.isWiFiInterface(iface) {
		fmt.Println("\n⚠ WARNING: WiFi interface detected")
		fmt.Println("WiFi on macOS does NOT support bridge networking properly")
		fmt.Println("Consider using Ethernet or port forwarding mode")
		fmt.Print("\nContinue anyway? (y/N): ")

		var response string
		fmt.Scanln(&response)
		if strings.ToLower(response) != "y" {
			return fmt.Errorf("setup cancelled")
		}
	}

	// Create configuration
	if err := b.createConfig(iface); err != nil {
		return err
	}

	// Start or restart service
	if b.IsRunning() {
		fmt.Println("Restarting socket_vmnet service...")
		if err := b.restart(); err != nil {
			return err
		}
	} else {
		fmt.Println("Starting socket_vmnet service...")
		if err := b.start(); err != nil {
			return err
		}
	}

	fmt.Println("✓ Bridge networking is ready!")
	return nil
}

// createConfig creates socket_vmnet configuration file
func (b *BridgeManager) createConfig(iface string) error {
	configDir := filepath.Join(b.brewPrefix, "etc/socket_vmnet")
	configFile := filepath.Join(configDir, "config")

	// Check if config already exists
	if _, err := os.Stat(configFile); err == nil {
		return nil
	}

	fmt.Println("Creating socket_vmnet configuration...")

	// Create config directory
	cmd := exec.Command("sudo", "mkdir", "-p", configDir)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write configuration
	content := fmt.Sprintf("# socket_vmnet configuration\n# Generated by LazyLinux VM Manager\ninterface %s\n", iface)

	cmd = exec.Command("sudo", "tee", configFile)
	cmd.Stdin = strings.NewReader(content)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Println("✓ Configuration created")
	return nil
}

// start starts socket_vmnet service
func (b *BridgeManager) start() error {
	cmd := exec.Command("sudo", "brew", "services", "start", "socket_vmnet")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to start socket_vmnet: %w", err)
	}
	return nil
}

// restart restarts socket_vmnet service
func (b *BridgeManager) restart() error {
	cmd := exec.Command("sudo", "brew", "services", "restart", "socket_vmnet")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to restart socket_vmnet: %w", err)
	}
	return nil
}

// detectPrimaryInterface detects the best network interface for bridge networking
func (b *BridgeManager) detectPrimaryInterface() (string, error) {
	// Try to find active Ethernet interfaces first (en1-en5)
	for i := 5; i >= 1; i-- {
		iface := fmt.Sprintf("en%d", i)
		if b.isInterfaceActive(iface) {
			return iface, nil
		}
	}

	// Fall back to en0 (usually WiFi)
	if b.isInterfaceActive("en0") {
		return "en0", nil
	}

	return "", fmt.Errorf("no active network interface found")
}

// isInterfaceActive checks if a network interface is active
func (b *BridgeManager) isInterfaceActive(iface string) bool {
	cmd := exec.Command("ifconfig", iface)
	output, err := cmd.Output()
	if err != nil {
		return false
	}

	content := string(output)
	return strings.Contains(content, "status: active") && strings.Contains(content, "inet ")
}

// isWiFiInterface checks if an interface is likely WiFi
func (b *BridgeManager) isWiFiInterface(iface string) bool {
	// en0 is typically WiFi on macOS
	return iface == "en0"
}
