#!/bin/bash

set -e

# Configuration
WORK_ROOT="$HOME/.vm"
IMAGES_DIR="$WORK_ROOT/images"
VMS_DIR="$WORK_ROOT/vms"
DEFAULT_USERNAME="user01"
DEFAULT_MEMORY="2G"
DEFAULT_CPUS="2"
DEFAULT_DISK="10G"
DEFAULT_IMAGE="debian13"

# Homebrew locations (fallback to /opt/homebrew when brew is unavailable)
BREW_PREFIX="$(brew --prefix 2>/dev/null || echo "/opt/homebrew")"
SOCKET_VMNET_SOCKET="$BREW_PREFIX/var/run/socket_vmnet"
SOCKET_VMNET_BINARY="$BREW_PREFIX/opt/socket_vmnet/bin/socket_vmnet"
SOCKET_VMNET_CLIENT="$BREW_PREFIX/opt/socket_vmnet/bin/socket_vmnet_client"

# Global variables for interrupt handling
CURRENT_VM_NAME=""
CURRENT_VM_DIR=""
INTERRUPT_CLEANUP=false

# Required binaries
REQUIRED_BINS=(
    "qemu-system-aarch64"
    "qemu-system-x86_64"
    "qemu-img"
    "hdiutil"
)

# Flag to track if QEMU was just installed
QEMU_JUST_INSTALLED=false

# Flag to track if image was just downloaded
IMAGE_JUST_DOWNLOADED=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
YELLOW='\033[0;33m'
DARK_YELLOW='\033[0;33m'
NC='\033[0m' # No Color

log() {
    echo "[$(date '+%H:%M:%S')] $*"
}

error() {
    echo "ERROR: $*" >&2
    exit 1
}

# Progress indicator functions
show_progress() {
    local message="$1"
    local vm_name="$2"
    
    # If QEMU was just installed or image was just downloaded, clear the current line first
    if [[ "$QEMU_JUST_INSTALLED" == "true" || "$IMAGE_JUST_DOWNLOADED" == "true" ]]; then
        echo -ne "\r\033[K" >&2  # Clear current line on stderr where the download indicator was
    else
        echo  # Start new line
    fi
    echo -ne "${DARK_YELLOW}⠋${NC} Creating VM \`${vm_name}\` in progress..."
}

show_success() {
    local vm_name="$1"
    local username="$2"
    local password="$3"
    local connection_info="$4"
    
    # Clear the progress line
    echo -ne "\r\033[K"
    echo -e "${GREEN}✔${NC} Your VM is ready and accessible via SSH with ${username}@${vm_name}.local using password: ${password}"
    if [[ -n "$connection_info" ]]; then
        echo "$connection_info"
    fi
}

show_error() {
    local reason="$1"
    
    # Clear the progress line
    echo -ne "\r\033[K"
    echo -e "${RED}✗${NC} VM creation failed: $reason"
}

update_progress() {
    local vm_name="$1"
    local step="$2"
    
    # Spinning dots animation using Braille patterns
    local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
    local frame_index=$((step % ${#frames[@]}))
    echo -ne "\r${DARK_YELLOW}${frames[$frame_index]}${NC} Creating VM \`${vm_name}\` in progress..."
}

get_image_url() {
    local image_name="$1"
    local arch="${2:-arm64}"
    
    case "$image_name" in
        debian13)
            if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
                echo "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-amd64.qcow2"
            else
                echo "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-arm64.qcow2"
            fi
            ;;
        debian12)
            if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
            else
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-arm64.qcow2"
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

check_dependencies() {
    local missing=()
    for bin in "${REQUIRED_BINS[@]}"; do
        if ! command -v "$bin" >/dev/null 2>&1; then
            missing+=("$bin")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        # Check if brew is available
        if command -v brew >/dev/null 2>&1; then
            # Show installation progress
            echo -ne "${BLUE}[i]${NC} Installing qemu..."
            if brew install qemu >/dev/null 2>&1; then
                # Clear the installation message and set flag
                echo -ne "\r\033[K"  # Clear line
                QEMU_JUST_INSTALLED=true
                
                # Verify installation
                local still_missing=()
                for bin in "${REQUIRED_BINS[@]}"; do
                    if ! command -v "$bin" >/dev/null 2>&1; then
                        still_missing+=("$bin")
                    fi
                done
                
                if [[ ${#still_missing[@]} -gt 0 ]]; then
                    error "Installation failed. Still missing: ${still_missing[*]}"
                fi
            else
                echo -ne "\r\033[K"  # Clear line
                error "Failed to install QEMU with brew. Please install manually: brew install qemu"
            fi
        else
            error "Missing dependencies: ${missing[*]}. Install Homebrew first, then run: brew install qemu"
        fi
    fi
}

socket_vmnet_process_running() {
    if command -v pgrep >/dev/null 2>&1; then
        if pgrep -f "$SOCKET_VMNET_BINARY" >/dev/null 2>&1; then
            return 0
        fi
        if pgrep -x socket_vmnetd >/dev/null 2>&1; then
            return 0
        fi
    else
        if ps aux | grep -v grep | grep -q "$SOCKET_VMNET_BINARY"; then
            return 0
        fi
        if ps aux | grep -v grep | grep -q "socket_vmnetd"; then
            return 0
        fi
    fi
    return 1
}

socket_vmnet_ready() {
    if socket_vmnet_process_running; then
        if [[ -S "$SOCKET_VMNET_SOCKET" ]]; then
            return 0
        fi
    fi
    return 1
}

check_socket_vmnet() {
    # Only check if we're using bridge networking
    if [[ "$1" != "bridge" ]]; then
        return 0
    fi

    # Check if socket_vmnet is installed
    if ! brew list socket_vmnet >/dev/null 2>&1; then
        echo -e "${YELLOW}[!]${NC} Bridge networking requires socket_vmnet."
        echo "Install and start it with: $0 setup-bridge"
        echo "Or use port forwarding: --net-type portfwd"
        return 1
    fi

    if socket_vmnet_ready; then
        return 0
    fi

    if socket_vmnet_process_running; then
        echo -e "${YELLOW}[!]${NC} socket_vmnet appears to be running but socket ${SOCKET_VMNET_SOCKET} is unavailable."
        echo "Try restarting it with: $0 setup-bridge"
        echo "Or use port forwarding: --net-type portfwd"
        return 1
    fi

    echo -e "${YELLOW}[!]${NC} socket_vmnet service is not running."
    echo "Start it with: $0 setup-bridge"
    echo "Or use port forwarding: --net-type portfwd"
    return 1
}

detect_primary_network_interface() {
    # Detect the best network interface for bridge networking
    # Priority: Ethernet adapters (en5, en4, etc) > en0 (often WiFi)
    # WiFi interfaces don't support bridging on macOS
    local interface=""
    local ethernet_interfaces=()

    # Find all active Ethernet adapters (exclude en0 initially, check it last)
    for if in en{5..1}; do
        if ifconfig "$if" 2>/dev/null | grep -q "status: active"; then
            # Check if it has an IP (likely Ethernet, not WiFi)
            if ifconfig "$if" 2>/dev/null | grep -q "inet "; then
                ethernet_interfaces+=("$if")
            fi
        fi
    done

    # Prefer non-en0 interfaces (likely USB Ethernet adapters)
    if [[ ${#ethernet_interfaces[@]} -gt 0 ]]; then
        interface="${ethernet_interfaces[0]}"
    else
        # Fall back to en0 if no other active interface found
        if ifconfig en0 2>/dev/null | grep -q "status: active"; then
            interface="en0"
        else
            # Last resort: find any active interface
            interface=$(ifconfig | grep -B 1 "status: active" | grep -o "^[a-z0-9]*" | head -1)
        fi
    fi

    echo "$interface"
}

is_wifi_interface() {
    local interface="$1"
    # en0 is typically WiFi on Mac
    # Also check if interface has WiFi capabilities
    if [[ "$interface" == "en0" ]]; then
        return 0  # Likely WiFi
    fi
    return 1  # Likely Ethernet
}

setup_bridge_networking() {
    local configure_sudo=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --configure-sudo)
                configure_sudo=true
                shift
                ;;
            --help|-h)
                cat <<EOF
Usage: $0 setup-bridge [--configure-sudo]

Setup bridge networking for VMs using socket_vmnet.

Options:
    --configure-sudo    Configure sudo to not require password for socket_vmnet_client
                        This allows VM creation without password prompts (optional)
    --help, -h          Show this help message

Without --configure-sudo, you will need to enter your password each time you
create or start a VM with bridge networking.
EOF
                return 0
                ;;
            *)
                error "Unknown option: $1. Use '$0 setup-bridge --help' for usage."
                ;;
        esac
    done

    echo "Setting up bridge networking (requires sudo password once)..."
    echo

    # Check if socket_vmnet is installed
    if ! brew list socket_vmnet >/dev/null 2>&1; then
        echo "Installing socket_vmnet..."
        if brew install socket_vmnet; then
            echo -e "${GREEN}✔${NC} socket_vmnet installed successfully"
        else
            error "Failed to install socket_vmnet"
        fi
    else
        echo -e "${GREEN}✔${NC} socket_vmnet is already installed"
    fi

    echo

    # Detect primary network interface
    local primary_interface=$(detect_primary_network_interface)
    if [[ -z "$primary_interface" ]]; then
        echo -e "${YELLOW}[!]${NC} Could not detect active network interface"
        echo "Please ensure you are connected to a network"
        return 1
    fi

    echo "Detected primary network interface: $primary_interface"
    local interface_ip=$(ifconfig "$primary_interface" | grep "inet " | awk '{print $2}')
    echo "Interface IP: $interface_ip"

    # Warn if using WiFi interface
    if is_wifi_interface "$primary_interface"; then
        echo
        echo -e "${YELLOW}[!] WARNING:${NC} The detected interface ($primary_interface) is likely WiFi"
        echo "    WiFi interfaces on macOS do NOT support bridge networking properly"
        echo "    VMs may not be able to obtain IP addresses or communicate on the network"
        echo
        echo "    Recommendations:"
        echo "    1. Use an Ethernet adapter (USB-C to Ethernet)"
        echo "    2. Or use port forwarding mode: ./vm create --net-type portfwd"
        echo
        read -p "Continue anyway? (y/N): " wifi_continue
        if [[ "$wifi_continue" != "y" && "$wifi_continue" != "Y" ]]; then
            echo "Setup cancelled. Use port forwarding mode or connect via Ethernet."
            return 1
        fi
    fi
    echo

    # Create socket_vmnet configuration directory
    local config_dir="$BREW_PREFIX/etc/socket_vmnet"
    local config_file="$config_dir/config"

    if [[ ! -f "$config_file" ]]; then
        echo "Creating socket_vmnet configuration..."
        echo "This requires sudo password to create config in $config_dir"

        # Create config directory if it doesn't exist
        sudo mkdir -p "$config_dir" || {
            error "Failed to create socket_vmnet config directory"
        }

        # Create configuration file
        sudo tee "$config_file" > /dev/null << EOF
# socket_vmnet configuration
# Generated by vm manager script
# Interface for bridge networking
interface $primary_interface
EOF

        if [[ -f "$config_file" ]]; then
            echo -e "${GREEN}✔${NC} Created configuration file: $config_file"
            echo "Configuration:"
            sudo cat "$config_file" | grep -v "^#" | grep -v "^$"
        else
            error "Failed to create socket_vmnet configuration file"
        fi
    else
        echo -e "${GREEN}✔${NC} Configuration file already exists: $config_file"
        echo "Current configuration:"
        sudo cat "$config_file" | grep -v "^#" | grep -v "^$"
    fi

    echo

    if socket_vmnet_ready; then
        echo -e "${YELLOW}[!]${NC} socket_vmnet service already running, restarting with new configuration..."
        if sudo brew services restart socket_vmnet; then
            echo -e "${GREEN}✔${NC} socket_vmnet service restarted"
        else
            error "Failed to restart socket_vmnet service"
        fi
    else
        echo "Starting socket_vmnet service (this will prompt for sudo password)..."
        if sudo brew services start socket_vmnet; then
            echo -e "${GREEN}✔${NC} socket_vmnet service started"
        else
            error "Failed to start socket_vmnet service"
        fi
    fi

    echo
    echo "Waiting for service to initialize..."
    sleep 3

    if socket_vmnet_ready; then
        echo -e "${GREEN}✔${NC} Bridge networking is ready!"
        echo "VMs will be bridged to interface: $primary_interface ($interface_ip)"
        echo

        # Configure sudo if requested
        if [[ "$configure_sudo" == "true" ]]; then
            local sudoers_file="/etc/sudoers.d/socket_vmnet_client"

            echo "Configuring sudo to allow passwordless execution of socket_vmnet_client..."
            echo
            echo -e "${YELLOW}WARNING:${NC} This will allow your user to run socket_vmnet_client without password."
            echo "This is generally safe as it only affects this specific command."
            echo
            echo "The following line will be added to $sudoers_file:"
            echo "  $USER ALL=(ALL) NOPASSWD: $SOCKET_VMNET_CLIENT"
            echo
            read -p "Continue? (y/N): " confirm

            if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                if echo "$USER ALL=(ALL) NOPASSWD: $SOCKET_VMNET_CLIENT" | sudo tee "$sudoers_file" > /dev/null; then
                    # Set correct permissions on sudoers file
                    sudo chmod 0440 "$sudoers_file"

                    # Validate sudoers file
                    if sudo visudo -c -f "$sudoers_file" >/dev/null 2>&1; then
                        echo -e "${GREEN}✔${NC} Sudo configuration successful!"
                        echo "You can now create VMs without password prompts:"
                        echo "  $0 create --net-type bridge"
                    else
                        echo -e "${RED}✗${NC} Sudoers file validation failed! Removing invalid file..."
                        sudo rm -f "$sudoers_file"
                        error "Failed to configure sudo. Please check permissions."
                    fi
                else
                    error "Failed to write sudoers file"
                fi
            else
                echo "Sudo configuration skipped."
                echo
                echo "Note: VM creation with bridge networking requires sudo access to socket_vmnet_client."
                echo "You will be prompted for your password when creating or starting VMs."
                echo
                echo "To configure sudo later, run:"
                echo "  $0 setup-bridge --configure-sudo"
            fi
        else
            echo "Note: VM creation with bridge networking requires sudo access to socket_vmnet_client."
            echo "You will be prompted for your password when creating or starting VMs."
            echo
            echo "To avoid password prompts, run:"
            echo "  $0 setup-bridge --configure-sudo"
        fi

        echo
        echo "You can now create VMs with bridge networking:"
        echo "  $0 create --net-type bridge"
    else
        echo -e "${YELLOW}[!]${NC} socket_vmnet service reported as running but socket ${SOCKET_VMNET_SOCKET} not found."
        echo "The service may need more time to initialize or may need a restart."
        echo "Try running: sudo brew services restart socket_vmnet"
        echo
        echo "You can also check the service logs with:"
        echo "  tail -f /opt/homebrew/var/log/socket_vmnet.log"
    fi
}

generate_password() {
    local length=${1:-16}
    LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "$length"
}

generate_random_vm_name() {
    # Generate a random VM name with format: adjective-noun-number (e.g., "independent-engine-345")
    local adjectives=("swift" "bright" "clever" "happy" "quick" "bold" "calm" "deep" "fast" "great" 
                      "kind" "light" "new" "old" "proud" "quiet" "rich" "safe" "tall" "warm"
                      "wise" "young" "big" "small" "strong" "weak" "hot" "cold" "dry" "wet"
                      "hard" "soft" "loud" "silent" "fresh" "stale" "clean" "dirty" "smooth" "rough"
                      "sharp" "dull" "thick" "thin" "wide" "narrow" "long" "short" "high" "low"
                      "independent" "reliable" "efficient" "modern" "classic" "stable" "dynamic" "secure")
    
    local nouns=("server" "engine" "cloud" "node" "host" "box" "core" "hub" "lab" "desk"
                 "tower" "bridge" "gate" "port" "net" "web" "link" "zone" "base" "unit"
                 "system" "device" "machine" "platform" "service" "cluster" "instance" "worker"
                 "runner" "builder" "manager" "handler" "monitor" "tracker" "scanner" "parser"
                 "router" "proxy" "cache" "store" "vault" "shield" "guard" "watch" "beacon" "signal")
    
    # Select random adjective and noun
    local adj_count=${#adjectives[@]}
    local noun_count=${#nouns[@]}
    local adjective=${adjectives[$((RANDOM % adj_count))]}
    local noun=${nouns[$((RANDOM % noun_count))]}
    
    # Generate random number between 100-999
    local number=$((RANDOM % 900 + 100))
    
    echo "${adjective}-${noun}-${number}"
}

is_port_free() {
    local port=$1
    ! lsof -i ":$port" >/dev/null 2>&1 && 
    ! nc -z 127.0.0.1 "$port" 2>/dev/null
}

find_free_port() {
    local preferred=$1
    
    if [[ -n "$preferred" && "$preferred" -gt 0 ]] && is_port_free "$preferred"; then
        echo "$preferred"
        return
    fi
    
    for port in $(seq 2222 9999); do
        # Skip commonly used ports
        case $port in 3000|3306|5000|5432|8000|8080|8443|9000) continue ;; esac
        
        if is_port_free "$port"; then
            echo "$port"
            return
        fi
    done
    
    error "No free port found"
}

download_image() {
    local image_name="$1"
    local arch="${2:-arm64}"
    local url
    url=$(get_image_url "$image_name" "$arch")
    
    if [[ -z "$url" ]]; then
        error "Unknown image: $image_name"
    fi
    
    local filename="${image_name}-${arch}.qcow2"
    local dest="$IMAGES_DIR/$filename"
    
    if [[ -f "$dest" ]]; then
        echo "$dest"
        return
    fi
    
    # Show download progress indicator (write to stderr to avoid command substitution capture)  
    echo -ne "${BLUE}[i]${NC} Downloading $image_name for $arch architecture..." >&2
    sync  # Ensure output is flushed
    mkdir -p "$IMAGES_DIR"
    
    local temp_file="$dest.tmp"
    if curl -L -s -f -o "$temp_file" "$url"; then
        if [[ ! -s "$temp_file" ]]; then
            rm -f "$temp_file"
            error "Downloaded file is empty: $image_name"
        fi
        
        if [[ "$url" == *.img ]]; then
            qemu-img convert -O qcow2 "$temp_file" "$dest" && rm "$temp_file" || {
                rm -f "$temp_file" "$dest"
                error "Failed to convert image: $image_name"
            }
        else
            mv "$temp_file" "$dest" || {
                rm -f "$temp_file"
                error "Failed to move image file: $image_name"
            }
        fi
        
        qemu-img info "$dest" >/dev/null 2>&1 || {
            rm -f "$dest"
            error "Downloaded image is not valid: $image_name"
        }
        
        sync
        # Clear the download message and set flag
        echo -ne "\r\033[K" >&2  # Clear line
        IMAGE_JUST_DOWNLOADED=true
        echo "$dest"
    else
        echo -ne "\r\033[K" >&2  # Clear line
        rm -f "$temp_file"
        error "Failed to download image: $image_name"
    fi
}

# Cleanup function for interrupted VM creation
cleanup_vm_on_interrupt() {
    if [[ "$INTERRUPT_CLEANUP" == "true" ]]; then
        return  # Already cleaning up
    fi
    INTERRUPT_CLEANUP=true
    
    echo -ne "\r\033[K"  # Clear current line
    echo -e "\033[0;31m✗\033[0m VM creation interrupted. Cleaning up..."
    
    if [[ -n "$CURRENT_VM_NAME" && -n "$CURRENT_VM_DIR" ]]; then
        local pid_file="$CURRENT_VM_DIR/qemu.pid"
        
        # Stop QEMU process if running
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                echo "Stopping QEMU process..."
                kill -TERM "$pid" 2>/dev/null || true
                sleep 2
                # Force kill if still running
                if kill -0 "$pid" 2>/dev/null; then
                    kill -KILL "$pid" 2>/dev/null || true
                fi
            fi
            rm -f "$pid_file"
        fi
        
        # Remove partial VM directory
        if [[ -d "$CURRENT_VM_DIR" ]]; then
            echo "Removing partial VM directory..."
            rm -rf "$CURRENT_VM_DIR"
        fi
        
        echo "Cleanup completed."
    fi
    
    exit 130  # Standard exit code for SIGINT
}

wait_for_cloud_init() {
    local console_log="$1"
    local timeout_seconds=${2:-300}
    local vm_name="$3"
    local count=0
    local step=0
    local timeout=$((timeout_seconds * 9))  # Adjust for 0.11s sleep intervals
    
    while [[ $count -lt $timeout ]]; do
        if [[ -f "$console_log" ]]; then
            if grep -q "CLOUD-INIT-READY" "$console_log" 2>/dev/null; then
                return 0
            fi
        fi
        
        # Update progress animation every 0.11 seconds (9x faster than original)
        update_progress "$vm_name" $step
        ((step++))
        
        sleep 0.11
        ((count += 1))
    done
    
    return 1
}

create_cloud_init() {
    local vm_dir="$1"
    local username="$2"
    local password="$3"
    local hostname="$4"
    local net_type="$5"

    # Sanitize hostname: replace underscores with hyphens (RFC 952/1123 compliant)
    hostname="${hostname//_/-}"

    # Create temporary directory for cloud-init files
    local tmpdir=$(mktemp -d)
    
    # Create user-data content with proper indentation
    local user_data=""
    if [[ "$net_type" == "bridge" ]]; then
        user_data=$(cat <<EOF
#cloud-config
datasource_list: [ NoCloud, None ]
final_message: "CLOUD-INIT-READY"
hostname: $hostname
fqdn: ${hostname}.local
manage_etc_hosts: true
package_update: false
packages:
  - openssh-server
  - avahi-daemon
output:
  all: '| tee -a /var/log/cloud-init-output.log'
write_files:
  - path: /etc/systemd/system/systemd-networkd-wait-online.service.d/override.conf
    content: |
      [Service]
      ExecStart=
      ExecStart=/lib/systemd/systemd-networkd-wait-online --timeout=3
  - path: /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg
    content: |
      network: {config: disabled}
  - path: /etc/netplan/01-netcfg.yaml
    content: |
      network:
        version: 2
        renderer: networkd
        ethernets:
          enp0s1:
            dhcp4: yes
            dhcp6: no
            nameservers:
              addresses: [8.8.8.8, 1.1.1.1]
  - path: /usr/local/bin/report-ip.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Wait for network to be ready
      sleep 5
      # Get IP address
      IP=\$(ip -4 addr show enp0s1 | grep -oP '(?<=inet\\s)\\d+(\\.\\d+){3}')
      if [ -n "\$IP" ]; then
          echo "VM_IP_ADDRESS: \$IP"
          logger "VM_IP_ADDRESS: \$IP"
      fi
users:
  - name: $username
    gecos: $username
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: [sudo]
    shell: /bin/bash
    lock_passwd: false
    plain_text_passwd: '$password'
ssh_pwauth: true
chpasswd:
  list: |
    $username:$password
  expire: false
write_files:
  - path: /etc/ssh/sshd_config.d/50-cloud-init.conf
    owner: root:root
    permissions: '0644'
    content: |
      PasswordAuthentication yes
      PubkeyAuthentication yes
      PermitRootLogin prohibit-password
      UseDNS no
      GSSAPIAuthentication no
runcmd:
  - |
    # Set hostname persistently
    hostnamectl set-hostname $hostname || echo "$hostname" > /etc/hostname
    hostname $hostname
  - echo "$username:$password" | chpasswd
  - passwd -u $username
  - systemctl enable ssh
  - systemctl enable avahi-daemon
  - |
    # Preserve SSH host keys across VM restarts
    if [ ! -f /etc/ssh/.keys_generated ]; then
      # Generate SSH host keys on first boot only
      ssh-keygen -A
      # Mark that keys have been generated to prevent regeneration
      touch /etc/ssh/.keys_generated
    fi
  - mkdir -p /etc/systemd/system/systemd-networkd-wait-online.service.d
  - systemctl daemon-reload
  - netplan apply
  - systemctl start ssh
  - systemctl start avahi-daemon
EOF
)
    else
        user_data=$(cat <<EOF
#cloud-config
datasource_list: [ NoCloud, None ]
final_message: "CLOUD-INIT-READY"
hostname: $hostname
fqdn: ${hostname}.local
manage_etc_hosts: true
package_update: false
packages:
  - openssh-server
  - avahi-daemon
output:
  all: '| tee -a /var/log/cloud-init-output.log'
users:
  - name: $username
    gecos: $username
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: [sudo]
    shell: /bin/bash
    lock_passwd: false
    plain_text_passwd: '$password'
ssh_pwauth: true
chpasswd:
  list: |
    $username:$password
  expire: false
write_files:
  - path: /etc/ssh/sshd_config.d/50-cloud-init.conf
    owner: root:root
    permissions: '0644'
    content: |
      PasswordAuthentication yes
      PubkeyAuthentication yes
      PermitRootLogin prohibit-password
      UseDNS no
      GSSAPIAuthentication no
runcmd:
  - |
    # Set hostname persistently
    hostnamectl set-hostname $hostname || echo "$hostname" > /etc/hostname
    hostname $hostname
  - echo "$username:$password" | chpasswd
  - passwd -u $username
  - systemctl enable ssh
  - systemctl enable avahi-daemon
  - |
    # Preserve SSH host keys across VM restarts
    if [ ! -f /etc/ssh/.keys_generated ]; then
      # Generate SSH host keys on first boot only
      ssh-keygen -A
      # Mark that keys have been generated to prevent regeneration
      touch /etc/ssh/.keys_generated
    fi
  - systemctl start ssh
  - systemctl start avahi-daemon
EOF
)
    fi

    local meta_data="{\"instance-id\": \"$hostname\", \"local-hostname\": \"$hostname\"}"
    local seed_iso="$vm_dir/seed.iso"
    
    echo "$user_data" > "$tmpdir/user-data"
    echo "$meta_data" > "$tmpdir/meta-data"
    
    # Save cloud-init config to VM directory for debugging
    echo "$user_data" > "$vm_dir/cloud-init-user-data.yaml"
    echo "$meta_data" > "$vm_dir/cloud-init-meta-data.json"
    
    # Create ISO using hdiutil
    if hdiutil makehybrid -o "$seed_iso" -hfs -joliet -iso -default-volume-name "cidata" "$tmpdir" >/dev/null 2>&1; then
        rm -rf "$tmpdir"
        echo "$seed_iso"
        return
    fi
    
    # Fallback to mkisofs/genisoimage
    if command -v mkisofs >/dev/null 2>&1; then
        mkisofs -V cidata -o "$seed_iso" -J -r "$tmpdir"
    elif command -v genisoimage >/dev/null 2>&1; then
        genisoimage -V cidata -o "$seed_iso" -J -r "$tmpdir"
    else
        rm -rf "$tmpdir"
        error "Failed to create cloud-init ISO. Install mkisofs or genisoimage"
    fi
    
    rm -rf "$tmpdir"
    echo "$seed_iso"
}

detect_firmware() {
    local arch="${1:-arm64}"
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 doesn't need explicit BIOS path, uses default
        return 0
    fi
    
    # ARM64 firmware candidates
    local candidates=(
        "/opt/homebrew/share/qemu/edk2-aarch64-code.fd"
        "/usr/local/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/edk2/aarch64/QEMU_EFI.fd"
        "/usr/share/AAVMF/AAVMF_CODE.fd"
    )
    
    for firmware in "${candidates[@]}"; do
        if [[ -f "$firmware" ]]; then
            echo "$firmware"
            return
        fi
    done
    
    error "AArch64 UEFI firmware not found. Install with: brew install qemu"
}

detect_bridge_vm_ip() {
    local vm_name="$1" username="$2"
    
    # Try hostname lookup
    if command -v nslookup >/dev/null 2>&1; then
        local ip=$(nslookup "$vm_name.local" 2>/dev/null | awk '/^Address: [0-9]/ {print $2}' | head -1)
        [[ -n "$ip" ]] && { echo "$ip"; return 0; }
    fi
    
    # Scan common bridge networks
    local ranges=("192.168.105" "192.168.100" "192.168.1")
    for range in "${ranges[@]}"; do
        for i in {10..50}; do
            local test_ip="$range.$i"
            if nc -z -w1 "$test_ip" 22 2>/dev/null; then
                echo "$test_ip"
                return 0
            fi
        done
    done
    
    return 1
}

generate_mac_address() {
    local vm_name="$1"
    # Generate a deterministic MAC address based on VM name to ensure consistency
    # Use 52:54:00 prefix (QEMU's default) and generate last 3 octets from VM name hash
    local hash=$(echo -n "$vm_name" | shasum -a 256 | cut -c1-6)
    local mac="52:54:00"
    for i in {1..3}; do
        local byte="${hash:$((($i-1)*2)):2}"
        mac="$mac:$byte"
    done
    echo "$mac"
}

build_qemu_args() {
    local name="$1"
    local arch="$2"
    local memory="$3"
    local cpus="$4"
    local ssh_port="$5"
    local vm_disk="$6"
    local firmware="$7"
    local net_type="$8"
    
    # Generate unique MAC address for this VM
    local mac_addr=$(generate_mac_address "$name")
    
    # Build array of arguments for QEMU
    local qemu_args=()
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 configuration
        qemu_args+=("qemu-system-x86_64")
        qemu_args+=("-machine" "q35")
        qemu_args+=("-cpu" "qemu64")
        qemu_args+=("-m" "$memory")
        qemu_args+=("-smp" "$cpus")
        qemu_args+=("-object" "memory-backend-ram,id=mem,size=$memory")
        qemu_args+=("-numa" "node,memdev=mem")
        qemu_args+=("-name" "$name")
        qemu_args+=("-device" "virtio-net-pci,netdev=n0,mac=$mac_addr")
        if [[ "$net_type" == "bridge" ]]; then
            qemu_args+=("-netdev" "socket,id=n0,fd=3")
        else
            qemu_args+=("-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22")
        fi
        qemu_args+=("-device" "virtio-rng-pci")
        qemu_args+=("-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2")
    else
        # ARM64 configuration
        qemu_args+=("qemu-system-aarch64")
        qemu_args+=("-machine" "virt")
        qemu_args+=("-cpu" "max")
        qemu_args+=("-bios" "$firmware")
        qemu_args+=("-m" "$memory")
        qemu_args+=("-smp" "$cpus")
        qemu_args+=("-name" "$name")
        qemu_args+=("-device" "virtio-net-pci,netdev=n0,mac=$mac_addr")
        if [[ "$net_type" == "bridge" ]]; then
            qemu_args+=("-netdev" "socket,id=n0,fd=3")
        else
            qemu_args+=("-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22")
        fi
        qemu_args+=("-device" "virtio-rng-pci")
        qemu_args+=("-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2")
    fi
    
    # Return all arguments
    printf '%s\n' "${qemu_args[@]}"
}

diagnose_network() {
    echo "=== Network Diagnostics ==="
    echo

    echo "1. Network Interfaces:"
    echo "   Primary interface: $(detect_primary_network_interface)"
    ifconfig | grep -E "^[a-z0-9]+:|status: active|inet " | head -20
    echo

    echo "2. socket_vmnet Status:"
    if brew list socket_vmnet >/dev/null 2>&1; then
        echo "   ✔ socket_vmnet is installed"

        local config_file="$BREW_PREFIX/etc/socket_vmnet/config"
        if [[ -f "$config_file" ]]; then
            echo "   ✔ Configuration file exists: $config_file"
            echo "   Content:"
            sudo cat "$config_file" 2>/dev/null || echo "   (cannot read without sudo)"
        else
            echo "   ✗ Configuration file missing: $config_file"
            echo "   Run: ./vm setup-bridge"
        fi
        echo

        if socket_vmnet_process_running; then
            echo "   ✔ socket_vmnet process is running"
        else
            echo "   ✗ socket_vmnet process is NOT running"
        fi

        if [[ -S "$SOCKET_VMNET_SOCKET" ]]; then
            echo "   ✔ Socket exists: $SOCKET_VMNET_SOCKET"
        else
            echo "   ✗ Socket missing: $SOCKET_VMNET_SOCKET"
        fi

        if socket_vmnet_ready; then
            echo "   ✔ socket_vmnet is ready for bridge networking"
        else
            echo "   ✗ socket_vmnet is NOT ready"
        fi

        # Check sudo configuration
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"
        if [[ -f "$sudoers_file" ]]; then
            echo "   ✔ Passwordless sudo is configured for socket_vmnet_client"
            echo "   VM creation will NOT require password"
        else
            echo "   ✗ Passwordless sudo NOT configured"
            echo "   VM creation WILL require password"
            echo "   To configure: ./vm setup-bridge --configure-sudo"
        fi
    else
        echo "   ✗ socket_vmnet is NOT installed"
        echo "   Run: ./vm setup-bridge"
    fi
    echo

    echo "3. QEMU Installation:"
    for bin in qemu-system-aarch64 qemu-system-x86_64 qemu-img; do
        if command -v "$bin" >/dev/null 2>&1; then
            echo "   ✔ $bin: $(command -v $bin)"
        else
            echo "   ✗ $bin: not found"
        fi
    done
    echo

    echo "4. Running VMs:"
    if pgrep -f "qemu-system" >/dev/null 2>&1; then
        ps aux | grep -E "qemu-system" | grep -v grep | awk '{print "   PID " $2 ": " $0}' | head -5
    else
        echo "   No QEMU processes running"
    fi
    echo

    echo "5. Port Usage (common SSH ports):"
    for port in 22 2222 2223 2224 2225; do
        if lsof -i ":$port" >/dev/null 2>&1; then
            echo "   Port $port: IN USE"
        else
            echo "   Port $port: free"
        fi
    done
    echo

    echo "=== Recommendations ==="
    if ! brew list socket_vmnet >/dev/null 2>&1; then
        echo "• Install socket_vmnet: ./vm setup-bridge"
    elif ! socket_vmnet_ready; then
        echo "• socket_vmnet not ready. Try: sudo brew services restart socket_vmnet"
    else
        echo "• Bridge networking appears to be configured correctly"
    fi

    local primary_if=$(detect_primary_network_interface)
    if [[ "$primary_if" =~ ^en0 ]]; then
        echo "• Note: en0 is typically WiFi on Mac. Bridge networking may have limitations."
        echo "  If you experience issues, try port forwarding mode: --net-type portfwd"
    fi
}

usage() {
    cat <<EOF
Usage: $0 COMMAND [options]

Commands:
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM
    delete VM_NAME      Delete a VM and its files
    ip VM_NAME          Find IP address of a bridge mode VM
    ssh VM_NAME         SSH into a VM
    purge               Delete all VMs (--force for no confirmation)
    setup-bridge        Setup bridge networking (one-time, requires sudo)
    diagnose            Run network diagnostics
    install             Install vm command to system PATH
    uninstall           Remove vm command from system PATH
    help                Show detailed help

Create options:
    --name NAME         VM name (optional - auto-generated if not provided)
    --arch ARCH         Architecture (default: arm64, options: arm64, amd64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --net-type TYPE     Network type (default: bridge, options: bridge, portfwd)
    --show-console      Show console output
    --debug             Show debug information including QEMU command

Examples:
    $0 setup-bridge                     # Setup bridge networking (one-time)
    $0 create                           # Create VM with auto-generated name
    $0 create --name myvm
    $0 create --arch amd64 --memory 4G
    $0 list
    $0 start myvm
    $0 ssh myvm
    $0 purge --force
    $0 install                          # Install to /usr/local/bin
EOF
}

# VM management functions - keeping existing functions but removing references to check_socket_vmnet in most places
# [Rest of the vm_create, vm_list, vm_start, vm_stop, etc. functions remain the same]
# I'll include the key modified sections:

vm_create() {
    local name=""
    local arch="arm64"
    local username="$DEFAULT_USERNAME"
    local password=""
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    local disk="$DEFAULT_DISK"
    local ssh_port=""
    local net_type="bridge"
    local show_console=false
    local debug=false
    
    # Set up interrupt handling
    trap cleanup_vm_on_interrupt SIGINT
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                name="$2"
                shift 2
                ;;
            --arch)
                arch="$2"
                shift 2
                ;;
            --user)
                username="$2"
                shift 2
                ;;
            --pass)
                password="$2"
                shift 2
                ;;
            --memory)
                memory="$2"
                shift 2
                ;;
            --cpus)
                cpus="$2"
                shift 2
                ;;
            --disk)
                disk="$2"
                shift 2
                ;;
            --ssh-port)
                ssh_port="$2"
                shift 2
                ;;
            --net-type)
                net_type="$2"
                if [[ "$net_type" != "bridge" && "$net_type" != "portfwd" ]]; then
                    error "Invalid network type: $net_type. Valid options: bridge, portfwd"
                fi
                shift 2
                ;;
            --show-console)
                show_console=true
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    # Generate random name if not provided
    if [[ -z "$name" ]]; then
        name=$(generate_random_vm_name)
    fi
    
    # Validate architecture
    if [[ "$arch" != "arm64" && "$arch" != "amd64" && "$arch" != "x86_64" ]]; then
        error "Invalid architecture: $arch. Options: arm64, amd64"
    fi
    
    # Normalize architecture
    [[ "$arch" == "x86_64" ]] && arch="amd64"

    # Check socket_vmnet if using bridge networking
    if ! check_socket_vmnet "$net_type"; then
        exit 1
    fi

    [[ -z "$password" ]] && password=$(generate_password 16)
    [[ -z "$ssh_port" ]] && ssh_port=$(find_free_port)
    
    local vm_dir="$VMS_DIR/$name"
    
    # Set global variables for cleanup
    CURRENT_VM_NAME="$name"
    CURRENT_VM_DIR="$vm_dir"
    
    # Check if VM already exists
    if [[ -d "$vm_dir" ]]; then
        local info_file="$vm_dir/info.json"
        if [[ -f "$info_file" ]]; then
            log "VM '$name' already exists. Checking if it's running..."
            local pid_file="$vm_dir/qemu.pid"
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file" 2>/dev/null)
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    local existing_port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
                    local existing_user=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
                    local existing_pass=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
                    error "VM '$name' is already running on port $existing_port (user: $existing_user, pass: $existing_pass)"
                fi
            fi
            log "VM directory exists but VM is not running. Recreating..."
        fi
    fi
    
    mkdir -p "$vm_dir"

    # Warn user about sudo requirement for bridge networking
    if [[ "$net_type" == "bridge" ]]; then
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"
        if [[ ! -f "$sudoers_file" ]]; then
            echo -e "${YELLOW}[!]${NC} Bridge networking requires sudo password for socket_vmnet_client"
            echo "    You will be prompted for your password when starting the VM..."
            echo "    To avoid this, run: ./vm setup-bridge --configure-sudo"
            echo
        fi
    fi

    # Download base image (suppress output)
    local base_image
    if ! base_image=$(download_image "$DEFAULT_IMAGE" "$arch"); then
        show_error "Failed to download base image"
        return 1
    fi

    # Show initial progress
    show_progress "Creating VM" "$name"
    
    # Create VM disk (suppress output)
    local vm_disk="$vm_dir/disk.qcow2"
    if [[ ! -f "$vm_disk" ]]; then
        if ! qemu-img convert -O qcow2 "$base_image" "$vm_disk" >/dev/null 2>&1; then
            show_error "Failed to create VM disk from base image"
            rm -f "$vm_disk"
            return 1
        fi
        
        if ! qemu-img resize "$vm_disk" "$disk" >/dev/null 2>&1; then
            show_error "Failed to resize VM disk"
            rm -f "$vm_disk"
            return 1
        fi
        
        sync
        
        if ! qemu-img info "$vm_disk" >/dev/null 2>&1; then
            show_error "Failed to create valid VM disk"
            rm -f "$vm_disk"
            return 1
        fi
    fi
    
    # Warn if VM name contains underscores (will be sanitized to hyphens)
    if [[ "$name" == *"_"* ]]; then
        local sanitized_name="${name//_/-}"
        echo -e "${YELLOW}[!]${NC} VM name contains underscores which are not valid in hostnames"
        echo "    Hostname will be sanitized to: $sanitized_name"
        echo "    SSH access will be: ssh $username@${sanitized_name}.local"
        echo
    fi

    # Create cloud-init seed (suppress output)
    local seed_iso
    if ! seed_iso=$(create_cloud_init "$vm_dir" "$username" "$password" "$name" "$net_type" 2>/dev/null); then
        show_error "Failed to create cloud-init configuration"
        return 1
    fi
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Save VM info
    local info_json="$vm_dir/info.json"
    if [[ "$net_type" == "bridge" ]]; then
        cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$DEFAULT_IMAGE",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "dhcp-assigned",
    "port": 22
  }
}
EOF
    else
        cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$DEFAULT_IMAGE",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    while IFS= read -r line; do
        qemu_args+=("$line")
    done < <(build_qemu_args "$name" "$arch" "$memory" "$cpus" "$ssh_port" "$vm_disk" "$firmware" "$net_type")
    
    # Add cloud-init for first boot only
    local first_boot_marker="$vm_dir/.first_boot_complete"
    qemu_args+=("-cdrom" "$seed_iso")
    
    # Add acceleration if available (only for ARM64 on macOS)
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Show debug information if requested
    if [[ "$debug" == true ]]; then
        echo "=== DEBUG INFO ==="
        echo "VM Name: $name"
        echo "Architecture: $arch"
        echo "Memory: $memory"
        echo "CPUs: $cpus"
        echo "Network Type: $net_type"
        echo "SSH Port: $ssh_port"
        echo "VM Disk: $vm_disk"
        echo "Seed ISO: $seed_iso"
        [[ -n "$firmware" ]] && echo "Firmware: $firmware"
        echo
        echo "Cloud-Init Configuration:"
        echo "------------------------"
        if [[ -f "$vm_dir/cloud-init-user-data.yaml" ]]; then
            echo "User Data:"
            cat "$vm_dir/cloud-init-user-data.yaml"
            echo
            echo "Meta Data:"
            cat "$vm_dir/cloud-init-meta-data.json"
        else
            echo "Cloud-init config files not found"
        fi
        echo "------------------------"
        echo
        echo "QEMU Command:"
        printf "%s " "${qemu_args[@]}"
        echo
        echo "=================="
        echo
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        echo "Starting VM with console (Ctrl+A then X to quit)"
        echo "Credentials: $username / $password"
        if [[ "$net_type" == "bridge" ]]; then
            echo "Network: Bridged mode (VM will get DHCP IP)"
        else
            echo "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        fi
        read -p "Press Enter to start..."
        if [[ "$net_type" == "bridge" ]]; then
            exec sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}"
        else
            exec "${qemu_args[@]}"
        fi
    else
        local console_log="$vm_dir/console.log"
        local pid_file="$vm_dir/qemu.pid"
        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "none"
            "-pidfile" "$pid_file"
        )
        
        # Try to start QEMU, with retry logic for port conflicts
        local max_retries=5
        local retry_count=0
        
        while [[ $retry_count -lt $max_retries ]]; do
            local qemu_success=false
            
            if [[ "$net_type" == "bridge" ]]; then
                if sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}" >/dev/null 2>&1; then
                    qemu_success=true
                    break
                fi
            else
                if "${qemu_args[@]}" >/dev/null 2>&1; then
                    qemu_success=true
                    break
                else
                    # Try with different port for portfwd mode
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -lt $max_retries ]]; then
                        ssh_port=$(find_free_port)
                        
                        # Update the QEMU args with new port
                        for i in "${!qemu_args[@]}"; do
                            if [[ "${qemu_args[i]}" =~ ^user,id=n0,hostfwd=tcp:127\.0\.0\.1:[0-9]+-:22$ ]]; then
                                qemu_args[i]="user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
                                break
                            fi
                        done
                        
                        # Update the info JSON
                        cat > "$info_json" <<EOF >/dev/null 2>&1
{
  "name": "$name",
  "arch": "$arch",
  "image": "$DEFAULT_IMAGE",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
                        sleep 1
                        continue
                    fi
                fi
            fi
            
            if [[ "$qemu_success" == false ]]; then
                retry_count=$((retry_count + 1))
                if [[ $retry_count -ge $max_retries ]]; then
                    show_error "Failed to start QEMU after $max_retries attempts"
                    return 1
                fi
                sleep 1
            fi
        done
        
        # Wait for cloud-init completion with progress animation
        if wait_for_cloud_init "$console_log" 300 "$name"; then
            touch "$first_boot_marker"
            # Clear interrupt handling once successful
            trap - SIGINT
            CURRENT_VM_NAME=""
            CURRENT_VM_DIR=""
            if [[ "$net_type" == "bridge" ]]; then
                show_success "$name" "$username" "$password" ""
            else
                show_success "$name" "$username" "$password" "(Alternative: ssh $username@127.0.0.1 -p $ssh_port)"
            fi
        else
            show_error "Cloud-init did not complete within 5 minutes"
            # Clean up on timeout
            cleanup_vm_on_interrupt
            return 1
        fi
    fi
    
    # Clear interrupt handling on normal completion
    trap - SIGINT
    CURRENT_VM_NAME=""
    CURRENT_VM_DIR=""
}

# Keeping the rest of the functions (vm_list, vm_start, vm_stop, vm_delete, etc.)
# They remain largely the same, I'll add them here for completeness:

vm_list() {
    if [[ ! -d "$VMS_DIR" ]]; then
        log "No VMs found (VMs directory doesn't exist)"
        return
    fi
    
    local vm_count=0
    echo
    printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "NAME" "STATUS" "ARCH" "IMAGE" "HOSTNAME" "CREDENTIALS"
    printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "----" "------" "----" "-----" "--------" "-----------"
    
    for vm_dir in "$VMS_DIR"/*; do
        if [[ ! -d "$vm_dir" ]]; then
            continue
        fi
        
        local vm_name=$(basename "$vm_dir")
        local info_file="$vm_dir/info.json"
        local pid_file="$vm_dir/qemu.pid"
        
        if [[ ! -f "$info_file" ]]; then
            printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "$vm_name" "BROKEN" "-" "-" "-" "-"
            ((vm_count++))
            continue
        fi
        
        local status="STOPPED"
        local ssh_info="-"
        local credentials="-"
        
        # Check if VM is running
        local is_running=false
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                is_running=true
            else
                # Clean up stale PID file
                rm -f "$pid_file"
            fi
        fi
        
        # Fallback check: look for running QEMU process with this VM name
        if [[ "$is_running" == "false" ]]; then
            if pgrep -f "qemu.*-name $vm_name" >/dev/null 2>&1; then
                is_running=true
            fi
        fi
        
        if [[ "$is_running" == "true" ]]; then
            status="RUNNING"
            
            # Extract info from JSON
            local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
            local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)
            
            # Default to portfwd if net_type is not found
            [[ -z "$net_type" ]] && net_type="portfwd"
            
            if [[ "$net_type" == "bridge" ]]; then
                ssh_info="$vm_name.local"
            else
                ssh_info="127.0.0.1:$port"
            fi
            credentials="$username / $password"
        fi
        
        # Get info from JSON file
        local arch=$(grep -o '"arch": "[^"]*"' "$info_file" | cut -d'"' -f4)
        local image=$(grep -o '"image": "[^"]*"' "$info_file" | cut -d'"' -f4)
        
        printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "$vm_name" "$status" "${arch:-arm64}" "${image:-unknown}" "$ssh_info" "$credentials"
        ((vm_count++))
    done
    
    if [[ $vm_count -eq 0 ]]; then
        echo "No VMs found"
    else
        echo
        echo "Total VMs: $vm_count"
    fi
}

vm_start() {
    local name="$1"
    local show_console=false
    local debug=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --show-console)
                show_console=true
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    local pid_file="$vm_dir/qemu.pid"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]] || [[ ! -f "$info_file" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if already running
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
            local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
            error "VM '$name' is already running on port $port (user: $username, pass: $password)"
        fi
        # Clean up stale PID file
        rm -f "$pid_file"
    fi
    
    log "Starting VM: $name"

    # Extract VM info
    local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local ssh_port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
    local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)

    # Default to portfwd if net_type is not found
    [[ -z "$net_type" ]] && net_type="portfwd"

    # Warn user about sudo requirement for bridge networking
    if [[ "$net_type" == "bridge" ]]; then
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"
        if [[ ! -f "$sudoers_file" ]]; then
            echo -e "${YELLOW}[!]${NC} Bridge networking requires sudo password for socket_vmnet_client"
            echo "    You will be prompted for your password..."
            echo "    To avoid this, run: ./vm setup-bridge --configure-sudo"
            echo
        fi
    fi

    # Check socket_vmnet if using bridge networking
    if ! check_socket_vmnet "$net_type"; then
        exit 1
    fi
    
    # Find a free port if the saved one is in use
    port_check_function() {
        local test_port=$1
        
        # First check with lsof
        if command -v lsof >/dev/null 2>&1; then
            if lsof -i ":$test_port" >/dev/null 2>&1; then
                return 1
            fi
        fi
        
        # Also check with netstat
        if command -v netstat >/dev/null 2>&1; then
            if netstat -an 2>/dev/null | grep -q "\\.$test_port " || netstat -an 2>/dev/null | grep -q ":$test_port "; then
                return 1
            fi
        fi
        
        return 0
    }
    
    if ! port_check_function "$ssh_port"; then
        log "Saved SSH port $ssh_port is in use, finding new port..."
        ssh_port=$(find_free_port)
        log "Using new SSH port: $ssh_port"
        
        # Update info.json with new port
        local temp_json=$(mktemp)
        sed "s/\"port\": [0-9]*/\"port\": $ssh_port/" "$info_file" > "$temp_json"
        mv "$temp_json" "$info_file"
    fi
    
    # Get VM files
    local vm_disk="$vm_dir/disk.qcow2"
    local seed_iso="$vm_dir/seed.iso"
    
    if [[ ! -f "$vm_disk" ]]; then
        error "VM disk not found: $vm_disk"
    fi
    
    # Get architecture from VM info
    local arch=$(grep -o '"arch": "[^"]*"' "$info_file" | cut -d'"' -f4)
    [[ -z "$arch" ]] && arch="arm64"
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    while IFS= read -r line; do
        qemu_args+=("$line")
    done < <(build_qemu_args "$name" "$arch" "$memory" "$cpus" "$ssh_port" "$vm_disk" "$firmware" "$net_type")
    
    # Only add cloud-init for fresh VMs
    local first_boot_marker="$vm_dir/.first_boot_complete"
    if [[ -f "$seed_iso" ]] && [[ ! -f "$first_boot_marker" ]]; then
        qemu_args+=("-cdrom" "$seed_iso")
    fi
    
    # Add acceleration if available
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Show debug information if requested
    if [[ "$debug" == true ]]; then
        echo "=== DEBUG INFO (VM START) ==="
        echo "VM Name: $name"
        echo "Architecture: $arch"
        echo "Network Type: $net_type"
        echo "SSH Port: $ssh_port"
        echo "VM Disk: $vm_disk"
        [[ -f "$seed_iso" && ! -f "$first_boot_marker" ]] && echo "Seed ISO: $seed_iso (first boot)"
        [[ -n "$firmware" ]] && echo "Firmware: $firmware"
        echo
        echo "QEMU Command:"
        printf "%s " "${qemu_args[@]}"
        echo
        echo "============================="
        echo
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        echo "Starting VM with console (Ctrl+A then X to quit)"
        echo "Credentials: $username / $password"
        if [[ "$net_type" == "bridge" ]]; then
            echo "Network: Bridged mode (VM will get DHCP IP)"
        else
            echo "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        fi
        read -p "Press Enter to start..."
        if [[ "$net_type" == "bridge" ]]; then
            exec sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}"
        else
            exec "${qemu_args[@]}"
        fi
    else
        local console_log="$vm_dir/console.log"
        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "none"
            "-pidfile" "$pid_file"
        )
        
        if [[ "$net_type" == "bridge" ]]; then
            bridge_success=0
            if sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}" 2>/dev/null; then
                bridge_success=0
            else
                bridge_success=1
            fi
        else
            bridge_success=0
            if "${qemu_args[@]}" 2>/dev/null; then
                bridge_success=0
            else
                bridge_success=1
            fi
        fi
        if [[ $bridge_success -eq 0 ]]; then
            # Wait for cloud-init completion if first boot
            if [[ ! -f "$first_boot_marker" ]]; then
                show_progress "Starting VM" "$name"
                if wait_for_cloud_init "$console_log" 300 "$name"; then
                    touch "$first_boot_marker"
                    if [[ "$net_type" == "bridge" ]]; then
                        show_success "$name" "$username" "$password" ""
                    else
                        show_success "$name" "$username" "$password" "(Alternative: ssh $username@127.0.0.1 -p $ssh_port)"
                    fi
                else
                    show_error "Cloud-init did not complete within 5 minutes"
                    return 1
                fi
            else
                # VM already initialized
                if [[ "$net_type" == "bridge" ]]; then
                    echo -e "${GREEN}✔${NC} VM ${name} is running and accessible via SSH with ${username}@${name}.local using password: ${password}"
                else
                    echo -e "${GREEN}✔${NC} VM ${name} is running and accessible via SSH with ${username}@${name}.local using password: ${password}"
                    echo "(Alternative: ssh $username@127.0.0.1 -p $ssh_port)"
                fi
            fi
        else
            show_error "Failed to start QEMU"
            return 1
        fi
    fi
}

vm_stop() {
    local name="$1"
    
    [[ -z "$name" ]] && error "VM name is required"
    
    local vm_dir="$VMS_DIR/$name"
    local pid_file="$vm_dir/qemu.pid"
    
    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi
    
    local pid=""
    if [[ -f "$pid_file" ]]; then
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            log "VM '$name' is not running (cleaning up stale PID file)"
            rm -f "$pid_file"
            pid=""
        fi
    fi
    
    if [[ -z "$pid" ]]; then
        pid=$(pgrep -f "qemu.*-name $name" | head -1)
        if [[ -z "$pid" ]]; then
            log "VM '$name' is not running"
            return
        fi
    fi
    
    log "Stopping VM: $name (PID: $pid)"

    # Check if process is owned by root (requires sudo)
    local process_owner=$(ps -o user= -p "$pid" 2>/dev/null)
    local use_sudo=false

    if [[ "$process_owner" == "root" ]]; then
        log "VM process is running as root, using sudo..."
        use_sudo=true
    fi

    # Try to stop the VM gracefully
    local kill_cmd="kill"
    [[ "$use_sudo" == "true" ]] && kill_cmd="sudo kill"

    if $kill_cmd -TERM "$pid" 2>/dev/null; then
        local count=0
        local timeout=30

        log "Sending graceful shutdown signal..."
        while [[ $count -lt $timeout ]] && kill -0 "$pid" 2>/dev/null; do
            sleep 1
            ((count++))
        done

        if kill -0 "$pid" 2>/dev/null; then
            log "Graceful shutdown timed out, forcing stop..."
            $kill_cmd -KILL "$pid" 2>/dev/null
            sleep 2
        fi

        if ! kill -0 "$pid" 2>/dev/null; then
            log "VM stopped successfully"
            rm -f "$pid_file"
        else
            error "Failed to stop VM"
        fi
    else
        error "Failed to send stop signal to VM (try: sudo ./vm stop $name)"
    fi
}

vm_ip() {
    local name="$1"
    [[ -z "$name" ]] && error "VM name is required"
    
    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    
    [[ ! -d "$vm_dir" || ! -f "$info_file" ]] && error "VM '$name' does not exist"
    
    local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)
    [[ -z "$net_type" ]] && net_type="portfwd"
    
    if [[ "$net_type" != "bridge" ]]; then
        local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
        echo "VM '$name' uses port forwarding: ssh user@127.0.0.1 -p $port"
        return
    fi
    
    local pid_file="$vm_dir/qemu.pid"
    if [[ ! -f "$pid_file" ]] || ! kill -0 "$(cat "$pid_file" 2>/dev/null)" 2>/dev/null; then
        echo "VM '$name' is not running"
        return
    fi
    
    local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
    echo "Searching for IP address of bridge VM '$name'..."
    
    local detected_ip
    if detected_ip=$(detect_bridge_vm_ip "$name" "$username"); then
        echo "Found IP: $detected_ip"
        echo "Connect with: ssh $username@$detected_ip"
        local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
        echo "Password: $password"
    else
        echo "Could not detect IP address. Check console log: cat $vm_dir/console.log"
    fi
}

vm_ssh() {
    local name="$1"
    [[ -z "$name" ]] && error "VM name is required"
    
    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    
    [[ ! -d "$vm_dir" || ! -f "$info_file" ]] && error "VM '$name' does not exist"
    
    local pid_file="$vm_dir/qemu.pid"
    if [[ ! -f "$pid_file" ]] || ! kill -0 "$(cat "$pid_file" 2>/dev/null)" 2>/dev/null; then
        error "VM '$name' is not running"
    fi
    
    local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)
    [[ -z "$net_type" ]] && net_type="portfwd"
    
    if [[ "$net_type" == "bridge" ]]; then
        local detected_ip
        if detected_ip=$(detect_bridge_vm_ip "$name" "$username"); then
            exec ssh "$username@$detected_ip"
        else
            error "Could not detect VM IP address. Use './linux vm ip $name' first"
        fi
    else
        local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
        exec ssh "$username@127.0.0.1" -p "$port"
    fi
}

vm_delete() {
    local name="$1"
    local force=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"
    
    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi
    
    local pid_file="$vm_dir/qemu.pid"
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log "Stopping running VM before deletion..."
            vm_stop "$name"
        fi
    fi
    
    if [[ "$force" == false ]]; then
        echo "This will permanently delete VM '$name' and all its data."
        read -p "Are you sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Deletion cancelled"
            return
        fi
    fi
    
    log "Deleting VM: $name"
    rm -rf "$vm_dir"
    log "VM '$name' deleted successfully"
}

purge() {
    local force=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force) force=true; shift ;;
            --help|-h) 
                echo "Usage: $0 purge [--force]"
                echo "  --force    Delete all VMs without confirmation"
                echo "  --help     Show this help"
                return 0
                ;;
            *) error "Unknown option: $1" ;;
        esac
    done
    
    local vm_count=0
    if [[ -d "$VMS_DIR" ]]; then
        for vm_dir in "$VMS_DIR"/*; do
            [[ -d "$vm_dir" ]] && ((vm_count++))
        done
    fi
    
    [[ $vm_count -eq 0 ]] && { log "No VMs found"; return; }
    
    log "Will delete $vm_count VM(s)"
    
    if [[ "$force" == false ]]; then
        echo "WARNING: This will permanently delete ALL VMs!"
        read -p "Are you sure? (y/N): " confirm
        [[ "$confirm" != "y" && "$confirm" != "Y" ]] && { log "Cancelled"; return; }
    fi
    
    log "Deleting VMs..."
    for vm_dir in "$VMS_DIR"/*; do
        [[ ! -d "$vm_dir" ]] && continue
        
        local vm_name=$(basename "$vm_dir")
        local pid_file="$vm_dir/qemu.pid"
        
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                kill -TERM "$pid" 2>/dev/null
                sleep 2
                kill -KILL "$pid" 2>/dev/null
            fi
        fi
        
        rm -rf "$vm_dir"
    done
    
    [[ -d "$VMS_DIR" ]] && rmdir "$VMS_DIR" 2>/dev/null
    [[ -d "$WORK_ROOT" ]] && rmdir "$WORK_ROOT" 2>/dev/null
    
    log "Deleted $vm_count VM(s)"
}

install_command() {
    local install_path="${1:-/usr/local/bin}"
    local script_path="$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")"
    local target_path="$install_path/vm"
    
    if [[ ! -f "$script_path" ]]; then
        error "Cannot find script at: $script_path"
    fi
    
    if [[ ! -d "$install_path" ]]; then
        error "Directory $install_path does not exist"
    fi
    
    echo "This will install the vm command to: $target_path"
    if [[ -f "$target_path" ]]; then
        echo "Warning: File already exists and will be overwritten"
    fi
    read -p "Continue? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        log "Installation cancelled"
        return
    fi
    
    if cp "$script_path" "$target_path" && chmod +x "$target_path"; then
        log "Successfully installed vm command to: $target_path"
        echo
        echo "You can now run: vm --help"
        echo "Make sure $install_path is in your PATH"
    else
        error "Failed to install. You may need to run with sudo: sudo $0 install"
    fi
}

uninstall_command() {
    local vm_path
    if vm_path=$(which vm 2>/dev/null); then
        echo "Found vm command at: $vm_path"
        read -p "Remove this file? (y/N): " confirm
        if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
            if rm "$vm_path"; then
                log "Successfully removed vm command from: $vm_path"
            else
                error "Failed to remove file. You may need sudo permissions"
            fi
        else
            log "Uninstall cancelled"
        fi
    else
        log "vm command not found in PATH - nothing to uninstall"
    fi
}

vm_help() {
    cat <<EOF
VM Manager - Create and manage Linux VMs on macOS

USAGE: $0 COMMAND [options]

COMMANDS:
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM
    delete VM_NAME      Delete a VM and its files
    ip VM_NAME          Find IP address of a bridge mode VM
    ssh VM_NAME         SSH into a VM
    purge               Delete all VMs (--force for no confirmation)
    setup-bridge        Setup bridge networking (one-time, requires sudo)
    diagnose            Run network diagnostics
    install             Install to system PATH (/usr/local/bin)
    uninstall           Remove from system PATH
    help                Show this help

CREATE OPTIONS:
    --name NAME         VM name (optional - auto-generated if not provided)
    --arch ARCH         Architecture: arm64, amd64 (default: arm64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --net-type TYPE     Network type (default: bridge, options: bridge, portfwd)
    --show-console      Show console output
    --debug             Show debug information

NETWORK TYPES:
    bridge          Bridged networking - VMs get IP from your network DHCP
                    • Requires socket_vmnet (run: ./vm setup-bridge)
                    • Requires sudo password when starting VMs (unless configured)
                    • VMs accessible via mDNS: ssh user@hostname.local
                    • Best for: VM-to-VM communication, network services

                    To avoid sudo password prompts (recommended):
                    ./vm setup-bridge --configure-sudo

    portfwd         Port forwarding - SSH via localhost ports
                    • No special setup required
                    • No sudo password needed
                    • VMs accessible via: ssh user@127.0.0.1 -p PORT
                    • Best for: Development, single VM access

EXAMPLES:
    $0 setup-bridge                         # Setup bridge networking (one-time)
    $0 setup-bridge --configure-sudo        # Setup + configure passwordless sudo
    $0 diagnose                             # Check network configuration
    $0 create                               # Create VM with random name (bridge mode)
    $0 create --name myvm
    $0 create --net-type portfwd            # Create VM with port forwarding
    $0 create --arch amd64 --memory 4G
    $0 list
    $0 start myvm                           # Will ask for sudo if bridge mode (unless configured)
    $0 ssh myvm
    $0 install                              # Install to /usr/local/bin
EOF
}

main() {
    local command="${1:-}"

    case "$command" in
        create)
            shift
            check_dependencies
            mkdir -p "$IMAGES_DIR" "$VMS_DIR"
            vm_create "$@"
            ;;
        list) mkdir -p "$VMS_DIR"; vm_list ;;
        start) shift; check_dependencies; vm_start "$@" ;;
        stop) shift; vm_stop "$@" ;;
        delete) shift; vm_delete "$@" ;;
        ip) shift; vm_ip "$@" ;;
        ssh) shift; vm_ssh "$@" ;;
        purge) shift; purge "$@" ;;
        setup-bridge) shift; setup_bridge_networking "$@" ;;
        diagnose) diagnose_network ;;
        install) shift; install_command "$@" ;;
        uninstall) shift; uninstall_command "$@" ;;
        help|--help|-h|"") vm_help ;;
        *) error "Unknown command: $command. Use '$0 help' for usage information." ;;
    esac
}

main "$@"