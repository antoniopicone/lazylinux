#!/bin/bash

set -e

# Check if running as root - this script should not be run as root
if [[ $EUID -eq 0 ]]; then
    echo "ERROR: This script should NOT be run as root or with sudo." >&2
    echo "" >&2
    echo "The script will prompt for sudo password when needed (e.g., for bridge networking)." >&2
    echo "Please run it as your normal user without sudo:" >&2
    echo "  ./vm <command>" >&2
    echo "" >&2
    exit 1
fi

# Configuration
WORK_ROOT="$HOME/.vm"
IMAGES_DIR="$WORK_ROOT/images"
VMS_DIR="$WORK_ROOT/vms"
DEFAULT_USERNAME="user01"
DEFAULT_MEMORY="4G"
DEFAULT_CPUS="2"
DEFAULT_DISK="10G"
DEFAULT_IMAGE="debian13"

# Homebrew locations (fallback to /opt/homebrew when brew is unavailable)
BREW_PREFIX="$(brew --prefix 2>/dev/null || echo "/opt/homebrew")"
SOCKET_VMNET_SOCKET="$BREW_PREFIX/var/run/socket_vmnet"
SOCKET_VMNET_BINARY="$BREW_PREFIX/opt/socket_vmnet/bin/socket_vmnet"
SOCKET_VMNET_CLIENT="$BREW_PREFIX/opt/socket_vmnet/bin/socket_vmnet_client"

# Global variables for interrupt handling
CURRENT_VM_NAME=""
CURRENT_VM_DIR=""
INTERRUPT_CLEANUP=false

# Required binaries
REQUIRED_BINS=(
    "qemu-system-aarch64"
    "qemu-system-x86_64"
    "qemu-img"
    "hdiutil"
)

# Flag to track if QEMU was just installed
QEMU_JUST_INSTALLED=false

# Flag to track if image was just downloaded
IMAGE_JUST_DOWNLOADED=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
YELLOW='\033[0;33m'
DARK_YELLOW='\033[0;33m'
NC='\033[0m' # No Color

log() {
    echo "[$(date '+%H:%M:%S')] $*"
}

error() {
    echo "ERROR: $*" >&2
    exit 1
}

# Sanitize hostname: replace underscores with hyphens (RFC 952/1123 compliance)
sanitize_hostname() {
    local name="$1"
    echo "${name//_/-}"
}

# JSON helper functions
json_get_string() {
    local file="$1"
    local field="$2"
    grep -o "\"$field\": \"[^\"]*\"" "$file" 2>/dev/null | cut -d'"' -f4
}

json_get_number() {
    local file="$1"
    local field="$2"
    grep -o "\"$field\": [0-9]*" "$file" 2>/dev/null | awk '{print $2}'
}

# Process management helper functions
get_vm_pid() {
    local vm_name="$1"
    local vm_dir="$VMS_DIR/$vm_name"
    local pid_file="$vm_dir/qemu.pid"
    local pid=""

    # Try pidfile first
    if [[ -f "$pid_file" ]]; then
        pid=$(cat "$pid_file" 2>/dev/null || true)
        if [[ -n "$pid" ]] && ps -p "$pid" >/dev/null 2>&1; then
            echo "$pid"
            return 0
        fi
    fi

    # Fallback to pgrep
    pid=$(pgrep -f "qemu.*-name $vm_name" 2>/dev/null | head -1)
    if [[ -n "$pid" ]]; then
        echo "$pid"
        return 0
    fi

    return 1
}

is_vm_running() {
    local vm_name="$1"
    get_vm_pid "$vm_name" >/dev/null 2>&1
}

is_root_process() {
    local pid="$1"
    [[ $(ps -o user= -p "$pid" 2>/dev/null) == "root" ]]
}

fix_monitor_socket_permissions() {
    local monitor_socket="$1"

    [[ ! -S "$monitor_socket" ]] && return 1

    # Check if already accessible
    [[ -r "$monitor_socket" && -w "$monitor_socket" ]] && return 0

    # Try to fix permissions
    if sudo -n chmod 666 "$monitor_socket" 2>/dev/null; then
        return 0
    else
        sudo chmod 666 "$monitor_socket" 2>/dev/null || return 1
    fi
}

# Generate static IP from VM name (deterministic)
# Uses hash of VM name to generate last octet in range 100-254
generate_static_ip() {
    local vm_name="$1"
    # Use checksum to generate a number from the VM name
    local hash=$(echo -n "$vm_name" | cksum | cut -d' ' -f1)
    # Map to range 100-254 (155 possible values)
    local last_octet=$((100 + (hash % 155)))
    echo "192.168.105.$last_octet"
}

# Get next available static IP by checking existing VMs
get_next_available_ip() {
    local base_ip="192.168.105"
    local used_ips=()

    # Collect all IPs currently in use
    if [[ -d "$VMS_DIR" ]]; then
        for vm_dir in "$VMS_DIR"/*; do
            if [[ -f "$vm_dir/info.json" ]]; then
                local ip=$(grep -o '"static_ip": "[^"]*"' "$vm_dir/info.json" 2>/dev/null | cut -d'"' -f4)
                if [[ -n "$ip" ]]; then
                    used_ips+=("$ip")
                fi
            fi
        done
    fi

    # Find first available IP in range 100-254
    for i in {100..254}; do
        local candidate="$base_ip.$i"
        local found=false
        for used in "${used_ips[@]}"; do
            if [[ "$used" == "$candidate" ]]; then
                found=true
                break
            fi
        done
        if [[ "$found" == false ]]; then
            echo "$candidate"
            return
        fi
    done

    # Fallback if all IPs are used (unlikely)
    echo "$base_ip.100"
}

# Validate IP address format
validate_ip() {
    local ip="$1"
    if [[ $ip =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        local IFS='.'
        local -a octets=($ip)
        for octet in "${octets[@]}"; do
            if [[ $octet -gt 255 ]] 2>/dev/null; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# Progress indicator functions
show_progress() {
    local message="$1"
    local vm_name="$2"
    
    # If QEMU was just installed or image was just downloaded, clear the current line first
    if [[ "$QEMU_JUST_INSTALLED" == "true" || "$IMAGE_JUST_DOWNLOADED" == "true" ]]; then
        echo -ne "\r\033[K" >&2  # Clear current line on stderr where the download indicator was
    else
        echo  # Start new line
    fi
    echo -ne "${DARK_YELLOW}⠋${NC} Creating VM \`${vm_name}\` in progress..."
}

show_success() {
    local vm_name="$1"
    local username="$2"
    local password="$3"
    local connection_info="$4"
    
    # Clear the progress line
    echo -ne "\r\033[K"
    echo -e "${GREEN}✔${NC} Your VM is ready and accessible via SSH with ${username}@${vm_name}.local using password: ${password}"
    if [[ -n "$connection_info" ]]; then
        echo "$connection_info"
    fi
}

show_error() {
    local reason="$1"
    
    # Clear the progress line
    echo -ne "\r\033[K"
    echo -e "${RED}✗${NC} VM creation failed: $reason"
}

update_progress() {
    local vm_name="$1"
    local step="$2"
    
    # Spinning dots animation using Braille patterns
    local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
    local frame_index=$((step % ${#frames[@]}))
    echo -ne "\r${DARK_YELLOW}${frames[$frame_index]}${NC} Creating VM \`${vm_name}\` in progress..."
}

get_image_url() {
    local image_name="$1"
    local arch="${2:-arm64}"
    
    case "$image_name" in
        debian13)
            if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
                echo "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-amd64.qcow2"
            else
                echo "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-arm64.qcow2"
            fi
            ;;
        debian12)
            if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
            else
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-arm64.qcow2"
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

check_dependencies() {
    local missing=()
    for bin in "${REQUIRED_BINS[@]}"; do
        if ! command -v "$bin" >/dev/null 2>&1; then
            missing+=("$bin")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        # Check if brew is available
        if command -v brew >/dev/null 2>&1; then
            # Show installation progress
            echo -ne "${BLUE}[i]${NC} Installing qemu..."
            if brew install qemu >/dev/null 2>&1; then
                # Clear the installation message and set flag
                echo -ne "\r\033[K"  # Clear line
                QEMU_JUST_INSTALLED=true
                
                # Verify installation
                local still_missing=()
                for bin in "${REQUIRED_BINS[@]}"; do
                    if ! command -v "$bin" >/dev/null 2>&1; then
                        still_missing+=("$bin")
                    fi
                done
                
                if [[ ${#still_missing[@]} -gt 0 ]]; then
                    error "Installation failed. Still missing: ${still_missing[*]}"
                fi
            else
                echo -ne "\r\033[K"  # Clear line
                error "Failed to install QEMU with brew. Please install manually: brew install qemu"
            fi
        else
            error "Missing dependencies: ${missing[*]}. Install Homebrew first, then run: brew install qemu"
        fi
    fi
}

socket_vmnet_process_running() {
    if command -v pgrep >/dev/null 2>&1; then
        if pgrep -f "$SOCKET_VMNET_BINARY" >/dev/null 2>&1; then
            return 0
        fi
        if pgrep -x socket_vmnetd >/dev/null 2>&1; then
            return 0
        fi
    else
        if ps aux | grep -v grep | grep -q "$SOCKET_VMNET_BINARY"; then
            return 0
        fi
        if ps aux | grep -v grep | grep -q "socket_vmnetd"; then
            return 0
        fi
    fi
    return 1
}

socket_vmnet_ready() {
    if socket_vmnet_process_running; then
        if [[ -S "$SOCKET_VMNET_SOCKET" ]]; then
            return 0
        fi
    fi
    return 1
}

check_socket_vmnet() {
    # Only check if we're using bridge networking
    if [[ "$1" != "bridge" ]]; then
        return 0
    fi

    # Check if socket_vmnet is installed
    if ! brew list socket_vmnet >/dev/null 2>&1; then
        echo -e "${YELLOW}[!]${NC} Bridge networking requires socket_vmnet."
        echo "Install and start it with: $0 setup-bridge"
        echo "Or use port forwarding: --net-type portfwd"
        return 1
    fi

    if socket_vmnet_ready; then
        return 0
    fi

    if socket_vmnet_process_running; then
        echo -e "${YELLOW}[!]${NC} socket_vmnet appears to be running but socket ${SOCKET_VMNET_SOCKET} is unavailable."
        echo "Try restarting it with: $0 setup-bridge"
        echo "Or use port forwarding: --net-type portfwd"
        return 1
    fi

    echo -e "${YELLOW}[!]${NC} socket_vmnet service is not running."
    echo "Start it with: $0 setup-bridge"
    echo "Or use port forwarding: --net-type portfwd"
    return 1
}

extract_vm_ip_from_log() {
    local console_log="$1"
    local max_wait="${2:-60}"  # Wait up to 60 seconds by default
    local elapsed=0
    local step=0

    # Spinner frames for animation
    local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

    while [[ $elapsed -lt $max_wait ]]; do
        if [[ -f "$console_log" ]]; then
            # Look for cloud-init network info line with IP address
            # Format: ci-info: | enp0s1 | True |       192.168.105.18       | ...
            local ip=$(grep "ci-info.*enp0s1.*True" "$console_log" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)

            if [[ -n "$ip" && "$ip" != "0.0.0.0" ]]; then
                echo -ne "\r\033[K" >&2  # Clear spinner before returning (to stderr)
                echo "$ip"
                return 0
            fi

            # Also check if cloud-init is ready (means network is configured)
            if grep -q "CLOUD-INIT-READY" "$console_log" 2>/dev/null; then
                # Cloud-init finished, try one more time
                ip=$(grep "ci-info.*enp0s1.*True" "$console_log" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
                if [[ -n "$ip" && "$ip" != "0.0.0.0" ]]; then
                    echo -ne "\r\033[K" >&2  # Clear spinner before returning (to stderr)
                    echo "$ip"
                    return 0
                fi
            fi
        fi

        # Update spinner animation (iterate every 0.2s for smooth animation)
        # Output to stderr so it doesn't get captured by command substitution
        for i in {1..10}; do
            local frame_index=$((step % ${#frames[@]}))
            echo -ne "\r${DARK_YELLOW}${frames[$frame_index]}${NC} VM booted, waiting for network DHCP to assign IP..." >&2
            sleep 0.2
            ((step++))
        done

        elapsed=$((elapsed + 2))
    done

    echo -ne "\r\033[K" >&2  # Clear spinner before returning on timeout (to stderr)
    return 1
}

update_vm_ip_in_info() {
    local info_file="$1"
    local ip_address="$2"

    if [[ ! -f "$info_file" ]]; then
        return 1
    fi

    # Create a temporary file with updated IP
    local temp_file=$(mktemp)

    # Read the current info.json and update the IP in ssh.host
    if command -v jq >/dev/null 2>&1; then
        # Use jq if available (more reliable)
        jq --arg ip "$ip_address" '.ssh.host = $ip' "$info_file" > "$temp_file"
    else
        # Fallback: use sed
        sed "s/\"host\": \"[^\"]*\"/\"host\": \"$ip_address\"/" "$info_file" > "$temp_file"
    fi

    # Replace the original file
    mv "$temp_file" "$info_file"
}

# Detect and update VM IP address for bridge mode
detect_and_update_vm_ip() {
    local vm_name="$1"
    local vm_dir="$VMS_DIR/$vm_name"
    local info_file="$vm_dir/info.json"
    local console_log="$vm_dir/console.log"
    local timeout="${2:-90}"

    local detected_ip=$(extract_vm_ip_from_log "$console_log" "$timeout")

    if [[ -n "$detected_ip" ]]; then
        update_vm_ip_in_info "$info_file" "$detected_ip"
        echo "$detected_ip"
        return 0
    fi

    return 1
}

# Launch QEMU daemon process
launch_qemu_daemon() {
    local vm_name="$1"
    local vm_dir="$2"
    local net_type="$3"
    shift 3
    local qemu_args=("$@")

    local console_log="$vm_dir/console.log"
    local pid_file="$vm_dir/qemu.pid"
    local monitor_socket="$vm_dir/monitor.sock"

    # Add daemon arguments
    qemu_args+=(
        "-daemonize"
        "-display" "none"
        "-serial" "file:$console_log"
        "-monitor" "unix:$monitor_socket,server,nowait"
    )

    # Only add pidfile for non-bridge mode
    if [[ "$net_type" != "bridge" ]]; then
        qemu_args+=("-pidfile" "$pid_file")
    fi

    # Launch QEMU
    if [[ "$net_type" == "bridge" ]]; then
        if sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}" >/dev/null 2>&1; then
            sleep 1
            fix_monitor_socket_permissions "$monitor_socket" || true
            return 0
        fi
    else
        if "${qemu_args[@]}" >/dev/null 2>&1; then
            return 0
        fi
    fi

    return 1
}

# Show VM ready message with connection info
show_vm_ready() {
    local vm_name="$1"
    local username="$2"
    local password="$3"
    local net_type="$4"
    local connection_detail="$5"

    local sanitized_name=$(sanitize_hostname "$vm_name")

    if [[ "$net_type" == "bridge" ]]; then
        echo -e "${GREEN}✔${NC} VM ${vm_name} is running and accessible via SSH with ${username}@${sanitized_name}.local using password: ${password}"
        [[ -n "$connection_detail" ]] && echo "$connection_detail"
    else
        echo -e "${GREEN}✔${NC} VM ${vm_name} is running and accessible via SSH with ${username}@127.0.0.1 -p ${connection_detail} using password: ${password}"
    fi
}

detect_primary_network_interface() {
    # Detect the best network interface for bridge networking
    # Priority: Ethernet adapters (en5, en4, etc) > en0 (often WiFi)
    # WiFi interfaces don't support bridging on macOS
    local interface=""
    local ethernet_interfaces=()

    # Find all active Ethernet adapters (exclude en0 initially, check it last)
    for if in en{5..1}; do
        if ifconfig "$if" 2>/dev/null | grep -q "status: active"; then
            # Check if it has an IP (likely Ethernet, not WiFi)
            if ifconfig "$if" 2>/dev/null | grep -q "inet "; then
                ethernet_interfaces+=("$if")
            fi
        fi
    done

    # Prefer non-en0 interfaces (likely USB Ethernet adapters)
    if [[ ${#ethernet_interfaces[@]} -gt 0 ]]; then
        interface="${ethernet_interfaces[0]}"
    else
        # Fall back to en0 if no other active interface found
        if ifconfig en0 2>/dev/null | grep -q "status: active"; then
            interface="en0"
        else
            # Last resort: find any active interface
            interface=$(ifconfig | grep -B 1 "status: active" | grep -o "^[a-z0-9]*" | head -1)
        fi
    fi

    echo "$interface"
}

is_wifi_interface() {
    local interface="$1"
    # en0 is typically WiFi on Mac
    # Also check if interface has WiFi capabilities
    if [[ "$interface" == "en0" ]]; then
        return 0  # Likely WiFi
    fi
    return 1  # Likely Ethernet
}

setup_bridge_networking() {
    echo "Setting up bridge networking with passwordless sudo (requires sudo password once)..."
    echo

    # Check if socket_vmnet is installed
    if ! brew list socket_vmnet >/dev/null 2>&1; then
        echo "Installing socket_vmnet..."
        if brew install socket_vmnet; then
            echo -e "${GREEN}✔${NC} socket_vmnet installed successfully"
        else
            error "Failed to install socket_vmnet"
        fi
    else
        echo -e "${GREEN}✔${NC} socket_vmnet is already installed"
    fi

    echo

    # Detect primary network interface
    local primary_interface=$(detect_primary_network_interface)
    if [[ -z "$primary_interface" ]]; then
        echo -e "${YELLOW}[!]${NC} Could not detect active network interface"
        echo "Please ensure you are connected to a network"
        return 1
    fi

    echo "Detected primary network interface: $primary_interface"
    local interface_ip=$(ifconfig "$primary_interface" | grep "inet " | awk '{print $2}')
    echo "Interface IP: $interface_ip"

    # Warn if using WiFi interface
    if is_wifi_interface "$primary_interface"; then
        echo
        echo -e "${YELLOW}[!] WARNING:${NC} The detected interface ($primary_interface) is likely WiFi"
        echo "    WiFi interfaces on macOS do NOT support bridge networking properly"
        echo "    VMs may not be able to obtain IP addresses or communicate on the network"
        echo
        echo "    Recommendations:"
        echo "    1. Use an Ethernet adapter (USB-C to Ethernet)"
        echo "    2. Or use port forwarding mode: ./vm create --net-type portfwd"
        echo
        read -p "Continue anyway? (y/N): " wifi_continue
        if [[ "$wifi_continue" != "y" && "$wifi_continue" != "Y" ]]; then
            echo "Setup cancelled. Use port forwarding mode or connect via Ethernet."
            return 1
        fi
    fi
    echo

    # Create socket_vmnet configuration directory
    local config_dir="$BREW_PREFIX/etc/socket_vmnet"
    local config_file="$config_dir/config"

    if [[ ! -f "$config_file" ]]; then
        echo "Creating socket_vmnet configuration..."
        echo "This requires sudo password to create config in $config_dir"

        # Create config directory if it doesn't exist
        sudo mkdir -p "$config_dir" || {
            error "Failed to create socket_vmnet config directory"
        }

        # Create configuration file
        sudo tee "$config_file" > /dev/null << EOF
# socket_vmnet configuration
# Generated by vm manager script
# Interface for bridge networking
interface $primary_interface
EOF

        if [[ -f "$config_file" ]]; then
            echo -e "${GREEN}✔${NC} Created configuration file: $config_file"
            echo "Configuration:"
            sudo cat "$config_file" | grep -v "^#" | grep -v "^$"
        else
            error "Failed to create socket_vmnet configuration file"
        fi
    else
        echo -e "${GREEN}✔${NC} Configuration file already exists: $config_file"
        echo "Current configuration:"
        sudo cat "$config_file" | grep -v "^#" | grep -v "^$"
    fi

    echo

    if socket_vmnet_ready; then
        echo -e "${YELLOW}[!]${NC} socket_vmnet service already running, restarting with new configuration..."
        if sudo brew services restart socket_vmnet; then
            echo -e "${GREEN}✔${NC} socket_vmnet service restarted"
        else
            error "Failed to restart socket_vmnet service"
        fi
    else
        echo "Starting socket_vmnet service (this will prompt for sudo password)..."
        if sudo brew services start socket_vmnet; then
            echo -e "${GREEN}✔${NC} socket_vmnet service started"
        else
            error "Failed to start socket_vmnet service"
        fi
    fi

    echo
    echo "Waiting for service to initialize..."
    sleep 3

    if socket_vmnet_ready; then
        echo -e "${GREEN}✔${NC} Bridge networking is ready!"
        echo "VMs will be bridged to interface: $primary_interface ($interface_ip)"
        echo

        # Configure passwordless sudo (always)
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"

        echo "Configuring sudo to allow passwordless execution of socket_vmnet_client..."
        echo
        echo -e "${YELLOW}INFO:${NC} This will allow your user to run socket_vmnet_client without password."
        echo "This is safe as it only affects specific commands for VM management."
        echo
        echo "The following lines will be added to $sudoers_file:"
        echo "  $USER ALL=(ALL) NOPASSWD: $SOCKET_VMNET_CLIENT"
        echo "  $USER ALL=(ALL) NOPASSWD: /bin/chmod 666 $HOME/.vm/vms/*/monitor.sock"
        echo
        echo "Note: The chmod permission is needed to fix monitor socket permissions after VM creation."
        echo
        read -p "Continue? (Y/n): " confirm

        if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
            echo "Setup cancelled."
            echo
            echo "Note: Without passwordless sudo, you will be prompted for your password"
            echo "every time you create or start a VM with bridge networking."
            return 1
        fi

        # Allow both socket_vmnet_client and chmod for monitor sockets
        cat <<EOF | sudo tee "$sudoers_file" > /dev/null
$USER ALL=(ALL) NOPASSWD: $SOCKET_VMNET_CLIENT
$USER ALL=(ALL) NOPASSWD: /bin/chmod 666 $HOME/.vm/vms/*/monitor.sock
EOF

        if [[ -f "$sudoers_file" ]]; then
            # Set correct permissions on sudoers file
            sudo chmod 0440 "$sudoers_file"

            # Validate sudoers file
            if sudo visudo -c -f "$sudoers_file" >/dev/null 2>&1; then
                echo -e "${GREEN}✔${NC} Sudo configuration successful!"
                echo
                echo "You can now create VMs without password prompts:"
                echo "  $0 create --net-type bridge"
            else
                echo -e "${RED}✗${NC} Sudoers file validation failed! Removing invalid file..."
                sudo rm -f "$sudoers_file"
                error "Failed to configure sudo. Please check permissions."
            fi
        else
            error "Failed to write sudoers file"
        fi

        echo
        echo "Bridge networking is fully configured!"
        echo "You can now create VMs with: $0 create --net-type bridge"
    else
        echo -e "${YELLOW}[!]${NC} socket_vmnet service reported as running but socket ${SOCKET_VMNET_SOCKET} not found."
        echo "The service may need more time to initialize or may need a restart."
        echo "Try running: sudo brew services restart socket_vmnet"
        echo
        echo "You can also check the service logs with:"
        echo "  tail -f /opt/homebrew/var/log/socket_vmnet.log"
    fi
}

generate_password() {
    local length=${1:-16}
    LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "$length"
}

generate_random_vm_name() {
    # Generate a random VM name with format: adjective-noun-number (e.g., "independent-engine-345")
    local adjectives=("swift" "bright" "clever" "happy" "quick" "bold" "calm" "deep" "fast" "great" 
                      "kind" "light" "new" "old" "proud" "quiet" "rich" "safe" "tall" "warm"
                      "wise" "young" "big" "small" "strong" "weak" "hot" "cold" "dry" "wet"
                      "hard" "soft" "loud" "silent" "fresh" "stale" "clean" "dirty" "smooth" "rough"
                      "sharp" "dull" "thick" "thin" "wide" "narrow" "long" "short" "high" "low"
                      "independent" "reliable" "efficient" "modern" "classic" "stable" "dynamic" "secure")
    
    local nouns=("server" "engine" "cloud" "node" "host" "box" "core" "hub" "lab" "desk"
                 "tower" "bridge" "gate" "port" "net" "web" "link" "zone" "base" "unit"
                 "system" "device" "machine" "platform" "service" "cluster" "instance" "worker"
                 "runner" "builder" "manager" "handler" "monitor" "tracker" "scanner" "parser"
                 "router" "proxy" "cache" "store" "vault" "shield" "guard" "watch" "beacon" "signal")
    
    # Select random adjective and noun
    local adj_count=${#adjectives[@]}
    local noun_count=${#nouns[@]}
    local adjective=${adjectives[$((RANDOM % adj_count))]}
    local noun=${nouns[$((RANDOM % noun_count))]}
    
    # Generate random number between 100-999
    local number=$((RANDOM % 900 + 100))
    
    echo "${adjective}-${noun}-${number}"
}

is_port_free() {
    local port=$1
    ! lsof -i ":$port" >/dev/null 2>&1 && 
    ! nc -z 127.0.0.1 "$port" 2>/dev/null
}

find_free_port() {
    local preferred=$1
    
    if [[ -n "$preferred" && "$preferred" -gt 0 ]] && is_port_free "$preferred"; then
        echo "$preferred"
        return
    fi
    
    for port in $(seq 2222 9999); do
        # Skip commonly used ports
        case $port in 3000|3306|5000|5432|8000|8080|8443|9000) continue ;; esac
        
        if is_port_free "$port"; then
            echo "$port"
            return
        fi
    done
    
    error "No free port found"
}

download_image() {
    local image_name="$1"
    local arch="${2:-arm64}"
    local url
    url=$(get_image_url "$image_name" "$arch")
    
    if [[ -z "$url" ]]; then
        error "Unknown image: $image_name"
    fi
    
    local filename="${image_name}-${arch}.qcow2"
    local dest="$IMAGES_DIR/$filename"
    
    if [[ -f "$dest" ]]; then
        echo "$dest"
        return
    fi
    
    # Show download progress indicator (write to stderr to avoid command substitution capture)  
    echo -ne "${BLUE}[i]${NC} Downloading $image_name for $arch architecture..." >&2
    sync  # Ensure output is flushed
    mkdir -p "$IMAGES_DIR"
    
    local temp_file="$dest.tmp"
    if curl -L -s -f -o "$temp_file" "$url"; then
        if [[ ! -s "$temp_file" ]]; then
            rm -f "$temp_file"
            error "Downloaded file is empty: $image_name"
        fi
        
        if [[ "$url" == *.img ]]; then
            qemu-img convert -O qcow2 "$temp_file" "$dest" && rm "$temp_file" || {
                rm -f "$temp_file" "$dest"
                error "Failed to convert image: $image_name"
            }
        else
            mv "$temp_file" "$dest" || {
                rm -f "$temp_file"
                error "Failed to move image file: $image_name"
            }
        fi
        
        qemu-img info "$dest" >/dev/null 2>&1 || {
            rm -f "$dest"
            error "Downloaded image is not valid: $image_name"
        }
        
        sync
        # Clear the download message and set flag
        echo -ne "\r\033[K" >&2  # Clear line
        IMAGE_JUST_DOWNLOADED=true
        echo "$dest"
    else
        echo -ne "\r\033[K" >&2  # Clear line
        rm -f "$temp_file"
        error "Failed to download image: $image_name"
    fi
}

# Cleanup function for interrupted VM creation
cleanup_vm_on_interrupt() {
    if [[ "$INTERRUPT_CLEANUP" == "true" ]]; then
        return  # Already cleaning up
    fi
    INTERRUPT_CLEANUP=true
    
    echo -ne "\r\033[K"  # Clear current line
    echo -e "\033[0;31m✗\033[0m VM creation interrupted. Cleaning up..."
    
    if [[ -n "$CURRENT_VM_NAME" && -n "$CURRENT_VM_DIR" ]]; then
        local pid_file="$CURRENT_VM_DIR/qemu.pid"
        
        # Stop QEMU process if running
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null || true)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                echo "Stopping QEMU process..."
                kill -TERM "$pid" 2>/dev/null || true
                sleep 2
                # Force kill if still running
                if kill -0 "$pid" 2>/dev/null; then
                    kill -KILL "$pid" 2>/dev/null || true
                fi
            fi
            rm -f "$pid_file"
        fi
        
        # Remove partial VM directory
        if [[ -d "$CURRENT_VM_DIR" ]]; then
            echo "Removing partial VM directory..."
            rm -rf "$CURRENT_VM_DIR"
        fi
        
        echo "Cleanup completed."
    fi
    
    exit 130  # Standard exit code for SIGINT
}

wait_for_cloud_init() {
    local console_log="$1"
    local timeout_seconds=${2:-300}
    local vm_name="$3"
    local count=0
    local step=0
    local timeout=$((timeout_seconds * 9))  # Adjust for 0.11s sleep intervals
    
    while [[ $count -lt $timeout ]]; do
        if [[ -f "$console_log" ]]; then
            if grep -q "CLOUD-INIT-READY" "$console_log" 2>/dev/null; then
                return 0
            fi
        fi
        
        # Update progress animation every 0.11 seconds (9x faster than original)
        update_progress "$vm_name" $step
        ((step++))
        
        sleep 0.11
        ((count += 1))
    done
    
    return 1
}

create_cloud_init() {
    local vm_dir="$1"
    local username="$2"
    local password="$3"
    local hostname="$4"
    local net_type="$5"
    local static_ip="$6"

    # Sanitize hostname: replace underscores with hyphens (RFC 952/1123 compliant)
    hostname="${hostname//_/-}"

    # Create temporary directory for cloud-init files
    local tmpdir=$(mktemp -d)

    # Build common packages list
    local packages="  - openssh-server
  - avahi-daemon"
    [[ "$net_type" == "bridge" ]] && packages+="
  - locales-all"

    # Build network configuration for bridge mode
    local network_config=""
    if [[ "$net_type" == "bridge" ]]; then
        # Determine network configuration based on static IP
        local netplan_config=""
        if [[ -n "$static_ip" ]]; then
            # Static IP configuration
            netplan_config="      network:
        version: 2
        renderer: networkd
        ethernets:
          enp0s1:
            addresses:
              - ${static_ip}/24
            routes:
              - to: default
                via: 192.168.105.1
            nameservers:
              addresses: [8.8.8.8, 1.1.1.1]
            dhcp4: no
            dhcp6: no"
        else
            # DHCP configuration (fallback)
            netplan_config="      network:
        version: 2
        renderer: networkd
        ethernets:
          enp0s1:
            dhcp4: yes
            dhcp6: no
            nameservers:
              addresses: [8.8.8.8, 1.1.1.1]"
        fi

        network_config="  - path: /etc/systemd/system/systemd-networkd-wait-online.service.d/override.conf
    content: |
      [Service]
      ExecStart=
      ExecStart=/lib/systemd/systemd-networkd-wait-online --timeout=3
  - path: /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg
    content: |
      network: {config: disabled}
  - path: /etc/netplan/01-netcfg.yaml
    content: |
$netplan_config
  - path: /usr/local/bin/report-ip.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      sleep 5
      IP=\$(ip -4 addr show enp0s1 | grep -oP '(?<=inet\\\\s)\\\\d+(\\\\.\\\\d+){3}')
      [ -n \"\$IP\" ] && echo \"VM_IP_ADDRESS: \$IP\" && logger \"VM_IP_ADDRESS: \$IP\"
"
    fi

    # Build runcmd based on network type
    local runcmd_extra=""
    [[ "$net_type" == "bridge" ]] && runcmd_extra="  - mkdir -p /etc/systemd/system/systemd-networkd-wait-online.service.d
  - systemctl daemon-reload
  - netplan apply
"

    # Generate unified cloud-init user-data
    user_data=$(cat <<EOF
#cloud-config
datasource_list: [ NoCloud, None ]
final_message: "CLOUD-INIT-READY"
hostname: $hostname
fqdn: ${hostname}.local
manage_etc_hosts: true
package_update: false
packages:
$packages
output:
  all: '| tee -a /var/log/cloud-init-output.log'
write_files:
$network_config  - path: /etc/ssh/sshd_config.d/50-cloud-init.conf
    owner: root:root
    permissions: '0644'
    content: |
      PasswordAuthentication yes
      PubkeyAuthentication yes
      PermitRootLogin prohibit-password
      UseDNS no
      GSSAPIAuthentication no
users:
  - name: $username
    gecos: $username
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: [sudo]
    shell: /bin/bash
    lock_passwd: false
    plain_text_passwd: '$password'
ssh_pwauth: true
chpasswd:
  list: |
    $username:$password
  expire: false
runcmd:
  - hostnamectl set-hostname $hostname || echo "$hostname" > /etc/hostname && hostname $hostname
  - echo "$username:$password" | chpasswd && passwd -u $username
  - systemctl enable ssh && systemctl enable avahi-daemon
  - [ ! -f /etc/ssh/.keys_generated ] && ssh-keygen -A && touch /etc/ssh/.keys_generated
$runcmd_extra  - systemctl start ssh && systemctl start avahi-daemon
EOF
)

    local meta_data="{\"instance-id\": \"$hostname\", \"local-hostname\": \"$hostname\"}"
    local seed_iso="$vm_dir/seed.iso"
    
    echo "$user_data" > "$tmpdir/user-data"
    echo "$meta_data" > "$tmpdir/meta-data"
    
    # Save cloud-init config to VM directory for debugging
    echo "$user_data" > "$vm_dir/cloud-init-user-data.yaml"
    echo "$meta_data" > "$vm_dir/cloud-init-meta-data.json"
    
    # Create ISO using hdiutil
    if hdiutil makehybrid -o "$seed_iso" -hfs -joliet -iso -default-volume-name "cidata" "$tmpdir" >/dev/null 2>&1; then
        rm -rf "$tmpdir"
        echo "$seed_iso"
        return
    fi
    
    # Fallback to mkisofs/genisoimage
    if command -v mkisofs >/dev/null 2>&1; then
        mkisofs -V cidata -o "$seed_iso" -J -r "$tmpdir"
    elif command -v genisoimage >/dev/null 2>&1; then
        genisoimage -V cidata -o "$seed_iso" -J -r "$tmpdir"
    else
        rm -rf "$tmpdir"
        error "Failed to create cloud-init ISO. Install mkisofs or genisoimage"
    fi
    
    rm -rf "$tmpdir"
    echo "$seed_iso"
}

detect_firmware() {
    local arch="${1:-arm64}"
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 doesn't need explicit BIOS path, uses default
        return 0
    fi
    
    # ARM64 firmware candidates
    local candidates=(
        "/opt/homebrew/share/qemu/edk2-aarch64-code.fd"
        "/usr/local/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/edk2/aarch64/QEMU_EFI.fd"
        "/usr/share/AAVMF/AAVMF_CODE.fd"
    )
    
    for firmware in "${candidates[@]}"; do
        if [[ -f "$firmware" ]]; then
            echo "$firmware"
            return
        fi
    done
    
    error "AArch64 UEFI firmware not found. Install with: brew install qemu"
}

detect_bridge_vm_ip() {
    local vm_name="$1" username="$2"
    
    # Try hostname lookup
    if command -v nslookup >/dev/null 2>&1; then
        local ip=$(nslookup "$vm_name.local" 2>/dev/null | awk '/^Address: [0-9]/ {print $2}' | head -1)
        [[ -n "$ip" ]] && { echo "$ip"; return 0; }
    fi
    
    # Scan common bridge networks
    local ranges=("192.168.105" "192.168.100" "192.168.1")
    for range in "${ranges[@]}"; do
        for i in {10..50}; do
            local test_ip="$range.$i"
            if nc -z -w1 "$test_ip" 22 2>/dev/null; then
                echo "$test_ip"
                return 0
            fi
        done
    done
    
    return 1
}

generate_mac_address() {
    local vm_name="$1"
    # Generate a deterministic MAC address based on VM name to ensure consistency
    # Use 52:54:00 prefix (QEMU's default) and generate last 3 octets from VM name hash
    local hash=$(echo -n "$vm_name" | shasum -a 256 | cut -c1-6)
    local mac="52:54:00"
    for i in {1..3}; do
        local byte="${hash:$((($i-1)*2)):2}"
        mac="$mac:$byte"
    done
    echo "$mac"
}

build_qemu_args() {
    local name="$1"
    local arch="$2"
    local memory="$3"
    local cpus="$4"
    local ssh_port="$5"
    local vm_disk="$6"
    local firmware="$7"
    local net_type="$8"
    
    # Generate unique MAC address for this VM
    local mac_addr=$(generate_mac_address "$name")
    
    # Build array of arguments for QEMU
    local qemu_args=()
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 configuration
        qemu_args+=("qemu-system-x86_64")
        qemu_args+=("-machine" "q35")
        qemu_args+=("-cpu" "qemu64")
        qemu_args+=("-m" "$memory")
        qemu_args+=("-smp" "$cpus")
        qemu_args+=("-object" "memory-backend-ram,id=mem,size=$memory")
        qemu_args+=("-numa" "node,memdev=mem")
        qemu_args+=("-name" "$name")
        qemu_args+=("-device" "virtio-net-pci,netdev=n0,mac=$mac_addr")
        if [[ "$net_type" == "bridge" ]]; then
            qemu_args+=("-netdev" "socket,id=n0,fd=3")
        else
            qemu_args+=("-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22")
        fi
        qemu_args+=("-device" "virtio-rng-pci")
        qemu_args+=("-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2")
    else
        # ARM64 configuration
        qemu_args+=("qemu-system-aarch64")
        qemu_args+=("-machine" "virt")
        qemu_args+=("-cpu" "max")
        qemu_args+=("-bios" "$firmware")
        qemu_args+=("-m" "$memory")
        qemu_args+=("-smp" "$cpus")
        qemu_args+=("-name" "$name")
        qemu_args+=("-device" "virtio-net-pci,netdev=n0,mac=$mac_addr")
        if [[ "$net_type" == "bridge" ]]; then
            qemu_args+=("-netdev" "socket,id=n0,fd=3")
        else
            qemu_args+=("-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22")
        fi
        qemu_args+=("-device" "virtio-rng-pci")
        qemu_args+=("-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2")
    fi
    
    # Return all arguments
    printf '%s\n' "${qemu_args[@]}"
}

diagnose_network() {
    echo "=== Network Diagnostics ==="
    echo

    echo "1. Network Interfaces:"
    echo "   Primary interface: $(detect_primary_network_interface)"
    ifconfig | grep -E "^[a-z0-9]+:|status: active|inet " | head -20
    echo

    echo "2. socket_vmnet Status:"
    if brew list socket_vmnet >/dev/null 2>&1; then
        echo "   ✔ socket_vmnet is installed"

        local config_file="$BREW_PREFIX/etc/socket_vmnet/config"
        if [[ -f "$config_file" ]]; then
            echo "   ✔ Configuration file exists: $config_file"
            echo "   Content:"
            sudo cat "$config_file" 2>/dev/null || echo "   (cannot read without sudo)"
        else
            echo "   ✗ Configuration file missing: $config_file"
            echo "   Run: ./vm setup-bridge"
        fi
        echo

        if socket_vmnet_process_running; then
            echo "   ✔ socket_vmnet process is running"
        else
            echo "   ✗ socket_vmnet process is NOT running"
        fi

        if [[ -S "$SOCKET_VMNET_SOCKET" ]]; then
            echo "   ✔ Socket exists: $SOCKET_VMNET_SOCKET"
        else
            echo "   ✗ Socket missing: $SOCKET_VMNET_SOCKET"
        fi

        if socket_vmnet_ready; then
            echo "   ✔ socket_vmnet is ready for bridge networking"
        else
            echo "   ✗ socket_vmnet is NOT ready"
        fi

        # Check sudo configuration
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"
        if [[ -f "$sudoers_file" ]]; then
            echo "   ✔ Passwordless sudo is configured for socket_vmnet_client"
            echo "   VM creation will NOT require password"
        else
            echo "   ✗ Passwordless sudo NOT configured"
            echo "   VM creation WILL require password"
            echo "   To configure: ./vm setup-bridge --configure-sudo"
        fi
    else
        echo "   ✗ socket_vmnet is NOT installed"
        echo "   Run: ./vm setup-bridge"
    fi
    echo

    echo "3. QEMU Installation:"
    for bin in qemu-system-aarch64 qemu-system-x86_64 qemu-img; do
        if command -v "$bin" >/dev/null 2>&1; then
            echo "   ✔ $bin: $(command -v $bin)"
        else
            echo "   ✗ $bin: not found"
        fi
    done
    echo

    echo "4. Running VMs:"
    if pgrep -f "qemu-system" >/dev/null 2>&1; then
        ps aux | grep -E "qemu-system" | grep -v grep | awk '{print "   PID " $2 ": " $0}' | head -5
    else
        echo "   No QEMU processes running"
    fi
    echo

    echo "5. Port Usage (common SSH ports):"
    for port in 22 2222 2223 2224 2225; do
        if lsof -i ":$port" >/dev/null 2>&1; then
            echo "   Port $port: IN USE"
        else
            echo "   Port $port: free"
        fi
    done
    echo

    echo "=== Recommendations ==="
    if ! brew list socket_vmnet >/dev/null 2>&1; then
        echo "• Install socket_vmnet: ./vm setup-bridge"
    elif ! socket_vmnet_ready; then
        echo "• socket_vmnet not ready. Try: sudo brew services restart socket_vmnet"
    else
        echo "• Bridge networking appears to be configured correctly"
    fi

    local primary_if=$(detect_primary_network_interface)
    if [[ "$primary_if" =~ ^en0 ]]; then
        echo "• Note: en0 is typically WiFi on Mac. Bridge networking may have limitations."
        echo "  If you experience issues, try port forwarding mode: --net-type portfwd"
    fi
}

usage() {
    cat <<EOF
Usage: $0 COMMAND [options]

Commands:
    install             Install vm command + setup bridge networking
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM
    delete VM_NAME      Delete a VM and its files
    ip VM_NAME          Find IP address of a bridge mode VM
    ssh VM_NAME         SSH into a VM
    purge               Delete all VMs (--force for no confirmation)
    diagnose            Run network diagnostics
    uninstall           Remove vm command from system PATH
    help                Show detailed help

Create options:
    --name NAME         VM name (optional - auto-generated if not provided)
                        Multiple VMs: Use comma-separated names (e.g., vm1,vm2,vm3)
                        Note: Underscores will be converted to hyphens for hostname compliance
    --arch ARCH         Architecture (default: arm64, options: arm64, amd64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --net-type TYPE     Network type (default: bridge, options: bridge, portfwd)
    --ip IP_ADDRESS     Static IP address for bridge mode (optional - auto-generated if not provided)
                        Auto-generated IPs are deterministic based on VM name (range: 192.168.105.100-254)
    --show-console      Show console output
    --debug             Show debug information including QEMU command

Examples:
    $0 install                          # Install + setup bridge networking (one-time)
    $0 create                           # Create VM with auto-generated name and IP
    $0 create --name myvm               # Create VM with deterministic auto-generated IP
    $0 create --name myvm --ip 192.168.105.150  # Create VM with specific static IP
    $0 create --name vm1,vm2,vm3 --user admin --pass test  # Create 3 VMs with same config
    $0 create --arch amd64 --memory 4G
    $0 list
    $0 start myvm
    $0 ssh myvm
    $0 diagnose                         # Check network configuration
    $0 purge --force
EOF
}

# VM management functions - keeping existing functions but removing references to check_socket_vmnet in most places
# [Rest of the vm_create, vm_list, vm_start, vm_stop, etc. functions remain the same]
# I'll include the key modified sections:

vm_create() {
    local name=""
    local arch="arm64"
    local username="$DEFAULT_USERNAME"
    local password=""
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    local disk="$DEFAULT_DISK"
    local ssh_port=""
    local net_type="bridge"
    local static_ip=""
    local show_console=false
    local debug=false

    # Set up interrupt handling
    trap cleanup_vm_on_interrupt SIGINT

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                name="$2"
                shift 2
                ;;
            --arch)
                arch="$2"
                shift 2
                ;;
            --user)
                username="$2"
                shift 2
                ;;
            --pass)
                password="$2"
                shift 2
                ;;
            --memory)
                memory="$2"
                shift 2
                ;;
            --cpus)
                cpus="$2"
                shift 2
                ;;
            --disk)
                disk="$2"
                shift 2
                ;;
            --ssh-port)
                ssh_port="$2"
                shift 2
                ;;
            --net-type)
                net_type="$2"
                if [[ "$net_type" != "bridge" && "$net_type" != "portfwd" ]]; then
                    error "Invalid network type: $net_type. Valid options: bridge, portfwd"
                fi
                shift 2
                ;;
            --ip)
                static_ip="$2"
                if ! validate_ip "$static_ip"; then
                    error "Invalid IP address format: $static_ip"
                fi
                shift 2
                ;;
            --show-console)
                show_console=true
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    # Generate random name if not provided
    if [[ -z "$name" ]]; then
        name=$(generate_random_vm_name)
    fi

    # Check if name contains comma (multiple VMs to create)
    if [[ "$name" == *","* ]]; then
        # Split names by comma and create each VM iteratively
        IFS=',' read -ra vm_names <<< "$name"
        local total_vms=${#vm_names[@]}
        local current_vm=0

        echo "Creating $total_vms VMs with shared configuration..."

        # Warn if user specified ssh-port or static IP (will be ignored for multi-VM)
        if [[ -n "$ssh_port" ]]; then
            echo -e "${YELLOW}[!]${NC} --ssh-port will be auto-assigned for each VM (specified port ignored for multi-VM creation)"
        fi
        if [[ -n "$static_ip" ]]; then
            echo -e "${YELLOW}[!]${NC} --ip will be auto-generated for each VM (specified IP ignored for multi-VM creation)"
        fi
        echo

        for vm_name in "${vm_names[@]}"; do
            # Trim whitespace
            vm_name=$(echo "$vm_name" | xargs)
            ((current_vm++))

            echo -e "${BLUE}[${current_vm}/${total_vms}]${NC} Creating VM: $vm_name"

            # Build arguments for recursive call
            local create_args=(
                "--name" "$vm_name"
                "--arch" "$arch"
                "--user" "$username"
                "--memory" "$memory"
                "--cpus" "$cpus"
                "--disk" "$disk"
                "--net-type" "$net_type"
            )

            # Add optional parameters if specified
            # Note: ssh_port and static_ip are intentionally NOT passed to allow auto-generation
            [[ -n "$password" ]] && create_args+=("--pass" "$password")
            [[ "$show_console" == true ]] && create_args+=("--show-console")
            [[ "$debug" == true ]] && create_args+=("--debug")

            # Recursively call vm_create for each VM
            if ! vm_create "${create_args[@]}"; then
                echo -e "${RED}✗${NC} Failed to create VM: $vm_name"
                echo
                continue
            fi

            echo
        done

        echo -e "${GREEN}✔${NC} Completed creating $total_vms VMs"
        echo
        echo "VM Summary:"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

        # Show summary of created VMs with their IPs
        for vm_name in "${vm_names[@]}"; do
            vm_name=$(echo "$vm_name" | xargs)
            local vm_info_file="$VMS_DIR/$vm_name/info.json"

            if [[ -f "$vm_info_file" ]]; then
                local vm_ip=$(json_get_string "$vm_info_file" "host")
                local vm_user=$(json_get_string "$vm_info_file" "username")

                if [[ -n "$vm_ip" && "$vm_ip" != "127.0.0.1" && "$vm_ip" != "dhcp-assigned" ]]; then
                    printf "  %-20s → %s (ssh %s@%s)\n" "$vm_name" "$vm_ip" "$vm_user" "$vm_ip"
                else
                    printf "  %-20s → %s.local (IP pending...)\n" "$vm_name" "$vm_name"
                fi
            fi
        done

        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        return 0
    fi

    # Check if VM name contains underscores (not RFC 952/1123 compliant)
    if [[ "$name" == *"_"* ]]; then
        local sanitized_name="${name//_/-}"
        echo -e "${YELLOW}[!]${NC} VM name contains underscores which are not valid in hostnames"
        echo "    Requested name: $name"
        echo "    Suggested name: $sanitized_name"
        echo
        read -p "Use suggested name '$sanitized_name'? (Y/n): " use_suggested

        if [[ "$use_suggested" == "n" || "$use_suggested" == "N" ]]; then
            error "VM creation cancelled. Please choose a hostname-compliant name (no underscores)."
        else
            echo "Using sanitized name: $sanitized_name"
            name="$sanitized_name"
            echo
        fi
    fi

    # Validate architecture
    if [[ "$arch" != "arm64" && "$arch" != "amd64" && "$arch" != "x86_64" ]]; then
        error "Invalid architecture: $arch. Options: arm64, amd64"
    fi

    # Normalize architecture
    [[ "$arch" == "x86_64" ]] && arch="amd64"

    # Check socket_vmnet if using bridge networking
    if ! check_socket_vmnet "$net_type"; then
        exit 1
    fi

    [[ -z "$password" ]] && password=$(generate_password 16)
    [[ -z "$ssh_port" ]] && ssh_port=$(find_free_port)

    # Generate static IP for bridge mode if not specified
    if [[ "$net_type" == "bridge" && -z "$static_ip" ]]; then
        static_ip=$(generate_static_ip "$name")
        # Check if IP is already in use, if so get next available
        if [[ -d "$VMS_DIR" ]]; then
            for existing_vm_dir in "$VMS_DIR"/*; do
                if [[ -f "$existing_vm_dir/info.json" ]]; then
                    local existing_ip=$(json_get_string "$existing_vm_dir/info.json" "static_ip")
                    if [[ "$existing_ip" == "$static_ip" ]]; then
                        static_ip=$(get_next_available_ip)
                        break
                    fi
                fi
            done
        fi
    fi

    local vm_dir="$VMS_DIR/$name"
    
    # Set global variables for cleanup
    CURRENT_VM_NAME="$name"
    CURRENT_VM_DIR="$vm_dir"
    
    # Check if VM already exists
    if [[ -d "$vm_dir" ]]; then
        local info_file="$vm_dir/info.json"
        if [[ -f "$info_file" ]]; then
            log "VM '$name' already exists. Checking if it's running..."
            if is_vm_running "$name"; then
                local existing_port=$(json_get_number "$info_file" "port")
                local existing_user=$(json_get_string "$info_file" "username")
                local existing_pass=$(json_get_string "$info_file" "password")
                error "VM '$name' is already running on port $existing_port (user: $existing_user, pass: $existing_pass)"
            fi
            log "VM directory exists but VM is not running. Recreating..."
        fi
    fi
    
    mkdir -p "$vm_dir"

    # Warn user about sudo requirement for bridge networking
    if [[ "$net_type" == "bridge" ]]; then
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"
        if [[ ! -f "$sudoers_file" ]]; then
            echo -e "${YELLOW}[!]${NC} Bridge networking requires sudo password for socket_vmnet_client"
            echo "    You will be prompted for your password when starting the VM..."
            echo "    To avoid this, run: ./vm setup-bridge --configure-sudo"
            echo
        fi
    fi

    # Download base image (suppress output)
    local base_image
    if ! base_image=$(download_image "$DEFAULT_IMAGE" "$arch"); then
        show_error "Failed to download base image"
        return 1
    fi

    # Show initial progress
    show_progress "Creating VM" "$name"
    
    # Create VM disk (suppress output)
    local vm_disk="$vm_dir/disk.qcow2"
    if [[ ! -f "$vm_disk" ]]; then
        if ! qemu-img convert -O qcow2 "$base_image" "$vm_disk" >/dev/null 2>&1; then
            show_error "Failed to create VM disk from base image"
            rm -f "$vm_disk"
            return 1
        fi
        
        if ! qemu-img resize "$vm_disk" "$disk" >/dev/null 2>&1; then
            show_error "Failed to resize VM disk"
            rm -f "$vm_disk"
            return 1
        fi
        
        sync
        
        if ! qemu-img info "$vm_disk" >/dev/null 2>&1; then
            show_error "Failed to create valid VM disk"
            rm -f "$vm_disk"
            return 1
        fi
    fi
    
    # Create cloud-init seed (suppress output)
    # Note: VM name is already sanitized at the beginning of vm_create
    local seed_iso
    if ! seed_iso=$(create_cloud_init "$vm_dir" "$username" "$password" "$name" "$net_type" "$static_ip" 2>/dev/null); then
        show_error "Failed to create cloud-init configuration"
        return 1
    fi
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Save VM info
    local info_json="$vm_dir/info.json"
    if [[ "$net_type" == "bridge" ]]; then
        cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$DEFAULT_IMAGE",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "static_ip": "$static_ip",
  "ssh": {
    "host": "$static_ip",
    "port": 22
  }
}
EOF
    else
        cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$DEFAULT_IMAGE",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    while IFS= read -r line; do
        qemu_args+=("$line")
    done < <(build_qemu_args "$name" "$arch" "$memory" "$cpus" "$ssh_port" "$vm_disk" "$firmware" "$net_type")
    
    # Add cloud-init for first boot only
    local first_boot_marker="$vm_dir/.first_boot_complete"
    qemu_args+=("-cdrom" "$seed_iso")
    
    # Add acceleration if available (only for ARM64 on macOS)
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Show debug information if requested
    if [[ "$debug" == true ]]; then
        echo "=== DEBUG INFO ==="
        echo "VM Name: $name"
        echo "Architecture: $arch"
        echo "Memory: $memory"
        echo "CPUs: $cpus"
        echo "Network Type: $net_type"
        echo "SSH Port: $ssh_port"
        echo "VM Disk: $vm_disk"
        echo "Seed ISO: $seed_iso"
        [[ -n "$firmware" ]] && echo "Firmware: $firmware"
        echo
        echo "Cloud-Init Configuration:"
        echo "------------------------"
        if [[ -f "$vm_dir/cloud-init-user-data.yaml" ]]; then
            echo "User Data:"
            cat "$vm_dir/cloud-init-user-data.yaml"
            echo
            echo "Meta Data:"
            cat "$vm_dir/cloud-init-meta-data.json"
        else
            echo "Cloud-init config files not found"
        fi
        echo "------------------------"
        echo
        echo "QEMU Command:"
        printf "%s " "${qemu_args[@]}"
        echo
        echo "=================="
        echo
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        echo "Starting VM with console (Ctrl+A then X to quit)"
        echo "Credentials: $username / $password"
        if [[ "$net_type" == "bridge" ]]; then
            echo "Network: Bridged mode (VM will get DHCP IP)"
        else
            echo "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        fi
        read -p "Press Enter to start..."
        if [[ "$net_type" == "bridge" ]]; then
            exec sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}"
        else
            exec "${qemu_args[@]}"
        fi
    else
        local console_log="$vm_dir/console.log"
        local pid_file="$vm_dir/qemu.pid"
        # Setup QEMU monitor socket for graceful shutdown
        local monitor_socket="$vm_dir/monitor.sock"

        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "unix:$monitor_socket,server,nowait"
        )

        # Only add pidfile for non-bridge mode (bridge mode runs as root, can't write to user dir)
        if [[ "$net_type" != "bridge" ]]; then
            qemu_args+=("-pidfile" "$pid_file")
        fi
        
        # Try to start QEMU, with retry logic for port conflicts
        local max_retries=5
        local retry_count=0
        
        while [[ $retry_count -lt $max_retries ]]; do
            local qemu_success=false
            
            if [[ "$net_type" == "bridge" ]]; then
                # Start QEMU - monitor socket permissions will be fixed after creation
                if sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}" >/dev/null 2>&1; then
                    qemu_success=true
                    # Note: QEMU will create the PID file automatically (as root)
                    # Our commands use fallback with pgrep if PID file can't be read

                    # Fix monitor socket permissions so user can access it without sudo
                    # Wait a moment for socket to be created
                    sleep 1
                    if [[ -S "$monitor_socket" ]]; then
                        sudo chmod 666 "$monitor_socket" 2>/dev/null || true
                    fi
                    break
                fi
            else
                if "${qemu_args[@]}" >/dev/null 2>&1; then
                    qemu_success=true
                    break
                else
                    # Try with different port for portfwd mode
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -lt $max_retries ]]; then
                        ssh_port=$(find_free_port)
                        
                        # Update the QEMU args with new port
                        for i in "${!qemu_args[@]}"; do
                            if [[ "${qemu_args[i]}" =~ ^user,id=n0,hostfwd=tcp:127\.0\.0\.1:[0-9]+-:22$ ]]; then
                                qemu_args[i]="user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
                                break
                            fi
                        done
                        
                        # Update the info JSON
                        cat > "$info_json" <<EOF >/dev/null 2>&1
{
  "name": "$name",
  "arch": "$arch",
  "image": "$DEFAULT_IMAGE",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
                        sleep 1
                        continue
                    fi
                fi
            fi
            
            if [[ "$qemu_success" == false ]]; then
                retry_count=$((retry_count + 1))
                if [[ $retry_count -ge $max_retries ]]; then
                    show_error "Failed to start QEMU after $max_retries attempts"
                    return 1
                fi
                sleep 1
            fi
        done
        
        # Wait for cloud-init completion with progress animation
        if wait_for_cloud_init "$console_log" 300 "$name"; then
            touch "$first_boot_marker"
            # Clear interrupt handling once successful
            trap - SIGINT
            CURRENT_VM_NAME=""
            CURRENT_VM_DIR=""

            # Extract IP address from console log for bridge mode VMs
            echo -ne "\r\033[K"  # Clear the progress line
            if [[ "$net_type" == "bridge" ]]; then
                local detected_ip=$(detect_and_update_vm_ip "$name" 90)
                if [[ -n "$detected_ip" ]]; then
                    show_success "$name" "$username" "$password" "IP Address: $detected_ip"
                else
                    show_success "$name" "$username" "$password" ""
                fi
            else
                show_success "$name" "$username" "$password" "(Alternative: ssh $username@127.0.0.1 -p $ssh_port)"
            fi
        else
            show_error "Cloud-init did not complete within 5 minutes"
            # Clean up on timeout
            cleanup_vm_on_interrupt
            return 1
        fi
    fi
    
    # Clear interrupt handling on normal completion
    trap - SIGINT
    CURRENT_VM_NAME=""
    CURRENT_VM_DIR=""
}

# Keeping the rest of the functions (vm_list, vm_start, vm_stop, vm_delete, etc.)
# They remain largely the same, I'll add them here for completeness:

vm_list() {
    if [[ ! -d "$VMS_DIR" ]]; then
        log "No VMs found (VMs directory doesn't exist)"
        return
    fi

    local vm_count=0
    echo
    printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "NAME" "STATUS" "ARCH" "IMAGE" "HOSTNAME" "CREDENTIALS"
    printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "----" "------" "----" "-----" "--------" "-----------"

    for vm_dir in "$VMS_DIR"/*; do
        if [[ ! -d "$vm_dir" ]]; then
            continue
        fi

        local vm_name=$(basename "$vm_dir")
        local info_file="$vm_dir/info.json"

        if [[ ! -f "$info_file" ]]; then
            printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "$vm_name" "BROKEN" "-" "-" "-" "-"
            ((vm_count++))
            continue
        fi

        local status="STOPPED"
        local ssh_info="-"
        local credentials="-"

        # Check if VM is running
        if is_vm_running "$vm_name"; then
            status="RUNNING"

            # Extract info from JSON using helper functions
            local port=$(json_get_number "$info_file" "port")
            local username=$(json_get_string "$info_file" "username")
            local password=$(json_get_string "$info_file" "password")
            local net_type=$(json_get_string "$info_file" "net_type")

            # Default to portfwd if net_type is not found
            [[ -z "$net_type" ]] && net_type="portfwd"

            if [[ "$net_type" == "bridge" ]]; then
                local sanitized_hostname=$(sanitize_hostname "$vm_name")
                ssh_info="${sanitized_hostname}.local"
            else
                ssh_info="127.0.0.1:$port"
            fi
            credentials="$username / $password"
        fi

        # Get info from JSON file
        local arch=$(json_get_string "$info_file" "arch")
        local image=$(json_get_string "$info_file" "image")

        printf "%-20s %-10s %-8s %-10s %-25s %-s\n" "$vm_name" "$status" "${arch:-arm64}" "${image:-unknown}" "$ssh_info" "$credentials"
        ((vm_count++))
    done

    if [[ $vm_count -eq 0 ]]; then
        echo "No VMs found"
    else
        echo
        echo "Total VMs: $vm_count"
    fi
}

vm_start() {
    local name="$1"
    local show_console=false
    local debug=false

    [[ -z "$name" ]] && error "VM name is required"

    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --show-console)
                show_console=true
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    local pid_file="$vm_dir/qemu.pid"

    # Check if VM exists
    if [[ ! -d "$vm_dir" ]] || [[ ! -f "$info_file" ]]; then
        echo -e "${RED}✖${NC} VM '$name' does not exist"
        echo -e "Create it with: ${GREEN}./vm create --name $name${NC}"
        exit 1
    fi

    # Check if already running
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null || true)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
            local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
            error "VM '$name' is already running on port $port (user: $username, pass: $password)"
        fi
        # Clean up stale PID file
        rm -f "$pid_file"
    fi

    log "Starting VM: $name"

    # Extract VM info using helper functions
    local username=$(json_get_string "$info_file" "username")
    local password=$(json_get_string "$info_file" "password")
    local ssh_port=$(json_get_number "$info_file" "port")
    local net_type=$(json_get_string "$info_file" "net_type")

    # Default to portfwd if net_type is not found
    [[ -z "$net_type" ]] && net_type="portfwd"

    # Warn user about sudo requirement for bridge networking
    if [[ "$net_type" == "bridge" ]]; then
        local sudoers_file="/etc/sudoers.d/socket_vmnet_client"
        if [[ ! -f "$sudoers_file" ]]; then
            echo -e "${YELLOW}[!]${NC} Bridge networking requires sudo password for socket_vmnet_client"
            echo "    You will be prompted for your password..."
            echo "    To avoid this, run: ./vm setup-bridge --configure-sudo"
            echo
        fi
    fi

    # Check socket_vmnet if using bridge networking
    if ! check_socket_vmnet "$net_type"; then
        exit 1
    fi
    
    # Find a free port if the saved one is in use
    port_check_function() {
        local test_port=$1
        
        # First check with lsof
        if command -v lsof >/dev/null 2>&1; then
            if lsof -i ":$test_port" >/dev/null 2>&1; then
                return 1
            fi
        fi
        
        # Also check with netstat
        if command -v netstat >/dev/null 2>&1; then
            if netstat -an 2>/dev/null | grep -q "\\.$test_port " || netstat -an 2>/dev/null | grep -q ":$test_port "; then
                return 1
            fi
        fi
        
        return 0
    }
    
    if ! port_check_function "$ssh_port"; then
        log "Saved SSH port $ssh_port is in use, finding new port..."
        ssh_port=$(find_free_port)
        log "Using new SSH port: $ssh_port"
        
        # Update info.json with new port
        local temp_json=$(mktemp)
        sed "s/\"port\": [0-9]*/\"port\": $ssh_port/" "$info_file" > "$temp_json"
        mv "$temp_json" "$info_file"
    fi
    
    # Get VM files
    local vm_disk="$vm_dir/disk.qcow2"
    local seed_iso="$vm_dir/seed.iso"

    if [[ ! -f "$vm_disk" ]]; then
        error "VM disk not found: $vm_disk"
    fi

    # Get architecture from VM info using helper function
    local arch=$(json_get_string "$info_file" "arch")
    [[ -z "$arch" ]] && arch="arm64"
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    while IFS= read -r line; do
        qemu_args+=("$line")
    done < <(build_qemu_args "$name" "$arch" "$memory" "$cpus" "$ssh_port" "$vm_disk" "$firmware" "$net_type")
    
    # Only add cloud-init for fresh VMs
    local first_boot_marker="$vm_dir/.first_boot_complete"
    if [[ -f "$seed_iso" ]] && [[ ! -f "$first_boot_marker" ]]; then
        qemu_args+=("-cdrom" "$seed_iso")
    fi
    
    # Add acceleration if available
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Show debug information if requested
    if [[ "$debug" == true ]]; then
        echo "=== DEBUG INFO (VM START) ==="
        echo "VM Name: $name"
        echo "Architecture: $arch"
        echo "Network Type: $net_type"
        echo "SSH Port: $ssh_port"
        echo "VM Disk: $vm_disk"
        [[ -f "$seed_iso" && ! -f "$first_boot_marker" ]] && echo "Seed ISO: $seed_iso (first boot)"
        [[ -n "$firmware" ]] && echo "Firmware: $firmware"
        echo
        echo "QEMU Command:"
        printf "%s " "${qemu_args[@]}"
        echo
        echo "============================="
        echo
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        echo "Starting VM with console (Ctrl+A then X to quit)"
        echo "Credentials: $username / $password"
        if [[ "$net_type" == "bridge" ]]; then
            echo "Network: Bridged mode (VM will get DHCP IP)"
        else
            echo "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        fi
        read -p "Press Enter to start..."
        if [[ "$net_type" == "bridge" ]]; then
            exec sudo "$SOCKET_VMNET_CLIENT" "$SOCKET_VMNET_SOCKET" "${qemu_args[@]}"
        else
            exec "${qemu_args[@]}"
        fi
    else
        # Launch QEMU daemon using helper function
        if launch_qemu_daemon "$name" "$vm_dir" "$net_type" "${qemu_args[@]}"; then
            # Wait for cloud-init completion if first boot
            if [[ ! -f "$first_boot_marker" ]]; then
                show_progress "Starting VM" "$name"
                if wait_for_cloud_init "$console_log" 300 "$name"; then
                    touch "$first_boot_marker"

                    # Extract IP address from console log for bridge mode VMs
                    if [[ "$net_type" == "bridge" ]]; then
                        local detected_ip=$(detect_and_update_vm_ip "$name" 90)
                        if [[ -n "$detected_ip" ]]; then
                            show_success "$name" "$username" "$password" "IP Address: $detected_ip"
                        else
                            show_success "$name" "$username" "$password" ""
                        fi
                    else
                        show_success "$name" "$username" "$password" "(Alternative: ssh $username@127.0.0.1 -p $ssh_port)"
                    fi
                else
                    show_error "Cloud-init did not complete within 5 minutes"
                    return 1
                fi
            else
                # VM already initialized - wait for network and detect IP
                sleep 3
                if [[ "$net_type" == "bridge" ]]; then
                    local saved_ip=$(json_get_string "$info_file" "host")
                    local detected_ip=$(detect_and_update_vm_ip "$name" 15)

                    if [[ -n "$detected_ip" ]]; then
                        show_vm_ready "$name" "$username" "$password" "$net_type" "IP Address: $detected_ip"
                    elif [[ -n "$saved_ip" && "$saved_ip" != "127.0.0.1" ]]; then
                        show_vm_ready "$name" "$username" "$password" "$net_type" "IP Address: $saved_ip (from previous session - may have changed)"
                    else
                        show_vm_ready "$name" "$username" "$password" "$net_type" "Use './vm ip ${name}' to get the current IP address"
                    fi
                else
                    show_vm_ready "$name" "$username" "$password" "$net_type" "$ssh_port"
                fi
            fi
        else
            show_error "Failed to start QEMU"
            return 1
        fi
    fi
}

vm_stop() {
    local name="$1"

    [[ -z "$name" ]] && error "VM name is required"

    log "Stopping VM: $name"
    local vm_dir="$VMS_DIR/$name"
    local pid_file="$vm_dir/qemu.pid"

    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi

    # Get VM PID using helper function
    local pid
    if ! pid=$(get_vm_pid "$name"); then
        log "VM '$name' is not running"
        rm -f "$pid_file"
        return
    fi

    # Check for multiple processes
    local all_pids=$(pgrep -f "qemu.*-name $name" 2>/dev/null || true)
    local pid_count=$(echo "$all_pids" | wc -w)
    if [[ $pid_count -gt 1 ]]; then
        log "WARNING: Found $pid_count QEMU processes for VM '$name'. Will stop all of them."
    fi

    log "Found VM process with PID: $pid. Sending shutdown signal..."

    # Try graceful ACPI shutdown via QEMU monitor if available
    local monitor_socket="$vm_dir/monitor.sock"
    local shutdown_success=false

    if [[ -S "$monitor_socket" ]]; then
        log "Attempting graceful ACPI shutdown via QEMU monitor..."
        fix_monitor_socket_permissions "$monitor_socket" 2>/dev/null || true

        # Try using socat if available, otherwise use nc (netcat)
        if command -v socat >/dev/null 2>&1; then
            if echo "system_powerdown" | socat - UNIX-CONNECT:"$monitor_socket" >/dev/null 2>&1; then
                shutdown_success=true
                log "ACPI shutdown signal sent successfully"
            fi
        elif command -v nc >/dev/null 2>&1; then
            if echo "system_powerdown" | nc -U "$monitor_socket" >/dev/null 2>&1; then
                shutdown_success=true
                log "ACPI shutdown signal sent successfully"
            fi
        fi
    fi

    # Fallback to kill signal if monitor not available
    if [[ "$shutdown_success" == false ]]; then
        log "QEMU monitor not available, using kill signal..."
        if is_root_process "$pid"; then
            # Try passwordless sudo first
            if sudo -n kill -TERM "$pid" >/dev/null 2>&1; then
                shutdown_success=true
            else
                # Cannot use interactive sudo in non-interactive context
                # Provide guidance on how to enable passwordless sudo
                echo ""
                echo "${YELLOW}WARNING:${NC} This VM is running as root and cannot be stopped without sudo access."
                echo ""
                echo "To enable passwordless VM stop, add this to your sudoers file:"
                echo "${GREEN}  $USER ALL=(root) NOPASSWD: /bin/kill${NC}"
                echo ""
                echo "Run this command to configure it:"
                echo "${GREEN}  echo '$USER ALL=(root) NOPASSWD: /bin/kill' | sudo tee /etc/sudoers.d/vm_manager_kill${NC}"
                echo ""
                echo "Or manually stop the VM with:"
                echo "${GREEN}  sudo kill -TERM $pid${NC}"
                echo ""
            fi
        else
            if kill -TERM "$pid" >/dev/null 2>&1; then
                shutdown_success=true
            fi
        fi
    fi

    if [[ "$shutdown_success" == true ]]; then
        local count=0
        local timeout=30

        log "Waiting for VM to shut down..."
        while [[ $count -lt $timeout ]] && ps -p "$pid" > /dev/null 2>&1; do
            sleep 1
            ((count++))
        done

        if ps -p "$pid" > /dev/null 2>&1; then
            log "Graceful shutdown timed out, forcing stop..."
            if is_root_process "$pid"; then
                sudo kill -KILL "$pid" 2>/dev/null
            else
                kill -KILL "$pid" 2>/dev/null
            fi
            sleep 2
        fi

        # Kill any remaining QEMU processes for this VM
        local remaining_pids=$(pgrep -f "qemu.*-name $name" 2>/dev/null || true)
        if [[ -n "$remaining_pids" ]]; then
            log "Cleaning up remaining QEMU processes..."
            for remaining_pid in $remaining_pids; do
                if [[ "$remaining_pid" != "$pid" ]]; then
                    log "Killing orphaned process: $remaining_pid"
                    if is_root_process "$remaining_pid"; then
                        sudo kill -KILL "$remaining_pid" 2>/dev/null || true
                    else
                        kill -KILL "$remaining_pid" 2>/dev/null || true
                    fi
                fi
            done
            sleep 1
        fi

        # Final check
        local final_check=$(pgrep -f "qemu.*-name $name" 2>/dev/null || true)
        if [[ -z "$final_check" ]]; then
            log "VM stopped successfully"
            rm -f "$pid_file"
        else
            error "Failed to stop all VM processes. Remaining PIDs: $final_check"
        fi
    else
        error "Failed to send stop signal to VM"
    fi
}

vm_ip() {
    local name="$1"
    [[ -z "$name" ]] && error "VM name is required"

    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"

    [[ ! -d "$vm_dir" || ! -f "$info_file" ]] && error "VM '$name' does not exist"

    local net_type=$(json_get_string "$info_file" "net_type")
    [[ -z "$net_type" ]] && net_type="portfwd"

    if [[ "$net_type" != "bridge" ]]; then
        local port=$(json_get_number "$info_file" "port")
        echo "VM '$name' uses port forwarding: ssh user@127.0.0.1 -p $port"
        return
    fi

    if ! is_vm_running "$name"; then
        echo "VM '$name' is not running"
        return
    fi

    local username=$(json_get_string "$info_file" "username")
    local password=$(json_get_string "$info_file" "password")
    local sanitized_hostname=$(sanitize_hostname "$name")
    local cached_ip=$(json_get_string "$info_file" "host")

    if [[ -n "$cached_ip" && "$cached_ip" != "dhcp-assigned" ]]; then
        echo "VM '$name' IP Address: $cached_ip"
        echo "Connect with: ssh $username@$cached_ip"
        echo "Or use mDNS: ssh $username@${sanitized_hostname}.local"
        echo "Password: $password"
        return 0
    fi

    # Fallback: try to extract from console log
    echo "Searching for IP address in VM console log..."
    local detected_ip=$(detect_and_update_vm_ip "$name" 5)

    if [[ -n "$detected_ip" ]]; then
        echo "Found IP: $detected_ip"
        echo "Connect with: ssh $username@$detected_ip"
        echo "Or use mDNS: ssh $username@${sanitized_hostname}.local"
        echo "Password: $password"
    else
        echo "Could not extract IP from console log"
        echo "Try mDNS: ssh $username@${sanitized_hostname}.local"
        echo "Password: $password"
        echo
        echo "Or check console log manually: cat $vm_dir/console.log | grep ci-info"
    fi
}

vm_ssh() {
    local name="$1"
    [[ -z "$name" ]] && error "VM name is required"

    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"

    [[ ! -d "$vm_dir" || ! -f "$info_file" ]] && error "VM '$name' does not exist"

    if ! is_vm_running "$name"; then
        error "VM '$name' is not running"
    fi

    local username=$(json_get_string "$info_file" "username")
    local net_type=$(json_get_string "$info_file" "net_type")
    [[ -z "$net_type" ]] && net_type="portfwd"

    if [[ "$net_type" == "bridge" ]]; then
        local detected_ip
        if detected_ip=$(detect_bridge_vm_ip "$name" "$username"); then
            exec ssh "$username@$detected_ip"
        else
            error "Could not detect VM IP address. Use './vm ip $name' first"
        fi
    else
        local port=$(json_get_number "$info_file" "port")
        exec ssh "$username@127.0.0.1" -p "$port"
    fi
}

vm_delete() {
    local name="$1"
    local force=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"

    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi

    # Check if VM is running and stop it
    if is_vm_running "$name"; then
        log "Stopping running VM before deletion..."
        vm_stop "$name"
    fi
    
    if [[ "$force" == false ]]; then
        echo "This will permanently delete VM '$name' and all its data."
        read -p "Are you sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Deletion cancelled"
            return
        fi
    fi
    
    log "Deleting VM: $name"
    rm -rf "$vm_dir"
    log "VM '$name' deleted successfully"
}

purge() {
    local force=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force) force=true; shift ;;
            --help|-h) 
                echo "Usage: $0 purge [--force]"
                echo "  --force    Delete all VMs without confirmation"
                echo "  --help     Show this help"
                return 0
                ;;
            *) error "Unknown option: $1" ;;
        esac
    done
    
    local vm_count=0
    if [[ -d "$VMS_DIR" ]]; then
        for vm_dir in "$VMS_DIR"/*; do
            [[ -d "$vm_dir" ]] && ((vm_count++))
        done
    fi
    
    [[ $vm_count -eq 0 ]] && { log "No VMs found"; return; }
    
    log "Will delete $vm_count VM(s)"
    
    if [[ "$force" == false ]]; then
        echo "WARNING: This will permanently delete ALL VMs!"
        read -p "Are you sure? (y/N): " confirm
        [[ "$confirm" != "y" && "$confirm" != "Y" ]] && { log "Cancelled"; return; }
    fi
    
    log "Deleting VMs..."
    for vm_dir in "$VMS_DIR"/*; do
        [[ ! -d "$vm_dir" ]] && continue
        
        local vm_name=$(basename "$vm_dir")
        local pid_file="$vm_dir/qemu.pid"
        
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null || true)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                kill -TERM "$pid" 2>/dev/null
                sleep 2
                kill -KILL "$pid" 2>/dev/null
            fi
        fi
        
        rm -rf "$vm_dir"
    done
    
    [[ -d "$VMS_DIR" ]] && rmdir "$VMS_DIR" 2>/dev/null
    [[ -d "$WORK_ROOT" ]] && rmdir "$WORK_ROOT" 2>/dev/null
    
    log "Deleted $vm_count VM(s)"
}

cleanup_orphaned_processes() {
    log "Checking for orphaned QEMU processes..."

    # Get all QEMU processes
    local all_qemu_pids=$(pgrep -f "qemu-system" 2>/dev/null || true)

    if [[ -z "$all_qemu_pids" ]]; then
        log "No QEMU processes found"
        return
    fi

    local orphaned_pids=()
    local orphaned_names=()

    # Check each QEMU process
    for qemu_pid in $all_qemu_pids; do
        # Get the VM name from the process command line
        local vm_name=$(ps -p "$qemu_pid" -o command= 2>/dev/null | grep -o '\-name [^ ]*' | cut -d' ' -f2)

        if [[ -z "$vm_name" ]]; then
            continue
        fi

        # Check if VM directory exists
        local vm_dir="$VMS_DIR/$vm_name"
        if [[ ! -d "$vm_dir" ]]; then
            orphaned_pids+=("$qemu_pid")
            orphaned_names+=("$vm_name")
        fi
    done

    if [[ ${#orphaned_pids[@]} -eq 0 ]]; then
        log "No orphaned QEMU processes found"
        return
    fi

    log "Found ${#orphaned_pids[@]} orphaned QEMU process(es):"

    # Check how many are root processes
    local root_count=0
    for qemu_pid in "${orphaned_pids[@]}"; do
        if is_root_process "$qemu_pid"; then
            ((root_count++))
        fi
    done

    for i in "${!orphaned_pids[@]}"; do
        local owner_label="user"
        is_root_process "${orphaned_pids[$i]}" && owner_label="root"
        echo "  - PID ${orphaned_pids[$i]}: VM '${orphaned_names[$i]}' (directory not found) [owner: $owner_label]"
    done

    if [[ $root_count -gt 0 ]]; then
        echo ""
        echo "Note: $root_count process(es) are owned by root and require sudo to kill"
    fi

    echo ""
    read -p "Kill these orphaned processes? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        log "Cleanup cancelled"
        return
    fi

    # If we have root processes, verify sudo access upfront
    if [[ $root_count -gt 0 ]]; then
        log "Verifying sudo access for root processes..."
        if ! sudo -v; then
            error "Cannot obtain sudo access"
        fi
    fi

    log "Killing orphaned processes..."
    local killed_count=0
    for qemu_pid in "${orphaned_pids[@]}"; do
        if ps -p "$qemu_pid" > /dev/null 2>&1; then
            if is_root_process "$qemu_pid"; then
                sudo kill -KILL "$qemu_pid" 2>/dev/null && ((killed_count++))
            else
                kill -KILL "$qemu_pid" 2>/dev/null && ((killed_count++))
            fi
        fi
    done

    log "Killed $killed_count orphaned process(es)"
}

install_command() {
    local install_path="${1:-/usr/local/bin}"
    local script_path="$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")"
    local target_path="$install_path/vm"

    echo "========================================"
    echo "  LazyLinux VM Manager Installation"
    echo "========================================"
    echo

    if [[ ! -f "$script_path" ]]; then
        error "Cannot find script at: $script_path"
    fi

    if [[ ! -d "$install_path" ]]; then
        error "Directory $install_path does not exist"
    fi

    echo "Step 1: Installing vm command to $target_path"
    if [[ -f "$target_path" ]]; then
        echo "Warning: File already exists and will be overwritten"
    fi
    read -p "Continue with installation? (Y/n): " confirm
    if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
        log "Installation cancelled"
        return
    fi

    if cp "$script_path" "$target_path" && chmod +x "$target_path"; then
        echo -e "${GREEN}✔${NC} Successfully installed vm command to: $target_path"
        echo

        # Run bridge networking setup
        echo "Step 2: Setting up bridge networking..."
        echo
        setup_bridge_networking

        echo
        echo "========================================"
        echo -e "${GREEN}✔ Installation Complete!${NC}"
        echo "========================================"
        echo
        echo "You can now run: vm --help"
        echo "Make sure $install_path is in your PATH"
        echo
        echo "To create your first VM:"
        echo "  vm create --name myvm"
    else
        error "Failed to install. You may need to run with sudo: sudo $0 install"
    fi
}

uninstall_command() {
    local vm_path
    if vm_path=$(which vm 2>/dev/null); then
        echo "Found vm command at: $vm_path"
        read -p "Remove this file? (y/N): " confirm
        if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
            if rm "$vm_path"; then
                log "Successfully removed vm command from: $vm_path"
            else
                error "Failed to remove file. You may need sudo permissions"
            fi
        else
            log "Uninstall cancelled"
        fi
    else
        log "vm command not found in PATH - nothing to uninstall"
    fi
}

vm_help() {
    cat <<EOF
VM Manager - Create and manage Linux VMs on macOS

USAGE: $0 COMMAND [options]

COMMANDS:
    install             Install vm command + setup bridge networking
    setup-bridge        Setup or reconfigure bridge networking (including sudo permissions)
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM
    delete VM_NAME      Delete a VM and its files
    ip VM_NAME          Find IP address of a bridge mode VM
    ssh VM_NAME         SSH into a VM
    purge               Delete all VMs (--force for no confirmation)
    cleanup             Find and kill orphaned QEMU processes
    diagnose            Run network diagnostics
    uninstall           Remove from system PATH
    help                Show this help

CREATE OPTIONS:
    --name NAME         VM name (optional - auto-generated if not provided)
                        Note: Underscores will be converted to hyphens for hostname compliance
    --arch ARCH         Architecture: arm64, amd64 (default: arm64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --net-type TYPE     Network type (default: bridge, options: bridge, portfwd)
    --show-console      Show console output
    --debug             Show debug information

NETWORK TYPES:
    bridge          Bridged networking - VMs get IP from your network DHCP
                    • Automatically configured during installation
                    • VMs accessible via mDNS: ssh user@hostname.local
                    • Best for: VM-to-VM communication, network services

    portfwd         Port forwarding - SSH via localhost ports
                    • No special setup required
                    • No sudo password needed
                    • VMs accessible via: ssh user@127.0.0.1 -p PORT
                    • Best for: Development, single VM access

INSTALLATION:
    First-time setup (installs vm command + configures bridge networking):
        $0 install

    This will:
        1. Install vm command to /usr/local/bin
        2. Install and configure socket_vmnet for bridge networking
        3. Configure passwordless sudo for VM operations

EXAMPLES:
    $0 install                              # First-time installation + setup
    $0 diagnose                             # Check network configuration
    $0 create                               # Create VM with random name (bridge mode)
    $0 create --name myvm
    $0 create --net-type portfwd            # Create VM with port forwarding
    $0 create --arch amd64 --memory 4G
    $0 list
    $0 start myvm
    $0 ssh myvm
    $0 ip myvm                              # Get VM IP address
EOF
}

main() {
    local command="${1:-}"

    case "$command" in
        create)
            shift
            check_dependencies
            mkdir -p "$IMAGES_DIR" "$VMS_DIR"
            vm_create "$@"
            ;;
        list) mkdir -p "$VMS_DIR"; vm_list ;;
        start) shift; check_dependencies; vm_start "$@" ;;
        stop) shift; vm_stop "$@" ;;
        delete) shift; vm_delete "$@" ;;
        ip) shift; vm_ip "$@" ;;
        ssh) shift; vm_ssh "$@" ;;
        purge) shift; purge "$@" ;;
        cleanup) cleanup_orphaned_processes ;;
        diagnose) diagnose_network ;;
        setup-bridge) shift; setup_bridge_networking "$@" ;;
        install) shift; install_command "$@" ;;
        uninstall) shift; uninstall_command "$@" ;;
        help|--help|-h|"") vm_help ;;
        *) error "Unknown command: $command. Use '$0 help' for usage information." ;;
    esac
}

main "$@"