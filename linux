#!/bin/bash

set -e

#TODO: static IP is still wrong but boot is quick, now
# Configuration
WORK_ROOT="$HOME/.linux"
IMAGES_DIR="$WORK_ROOT/images"
VMS_DIR="$WORK_ROOT/vms"
DEFAULT_USERNAME="user01"
DEFAULT_MEMORY="2G"
DEFAULT_CPUS="2"
DEFAULT_DISK="10G"

get_image_url() {
    local image_name="$1"
    local arch="${2:-arm64}"
    
    case "$image_name" in
        debian12)
            if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
            else
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-arm64.qcow2"
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

get_available_images() {
    echo "debian12 ubuntu22 ubuntu24"
}

# Required binaries
REQUIRED_BINS=(
    "qemu-system-aarch64"
    "qemu-system-x86_64"
    "qemu-img"
    "hdiutil"
)

usage() {
    cat <<EOF
Usage: $0 ENTITY COMMAND [options]

Entities:
    vm                  Virtual machine operations
    image               Image management operations

VM Commands:
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM
    delete VM_NAME      Delete a VM and its files
    help                Show detailed VM help

Image Commands:
    list                List available and downloaded images
    pull IMAGE_NAME     Download an image (e.g., debian12-arm64, debian12-amd64)
    delete IMAGE_NAME   Delete a downloaded image (e.g., debian12-arm64)
                        --force         Delete without confirmation
    help                Show detailed image help

System Commands:
    purge               Delete all VMs and downloaded images
                        --force         Purge without confirmation

VM Create options:
    --name NAME         VM name (required)
    --image IMAGE       Base image (default: debian12, options: debian12, ubuntu22, ubuntu24)
    --arch ARCH         Architecture (default: arm64, options: arm64, amd64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --net-type TYPE     Network type (default: bridge, options: bridge, portfwd)
    --show-console      Show console output
    --debug             Show debug information including QEMU command

Examples:
    $0 vm help                    # Show detailed VM help
    $0 image help                 # Show detailed image help
    $0 vm create --name myvm --arch amd64 --memory 4G --net-type portfwd
    $0 vm list
    $0 vm start myvm
    $0 image pull debian12-arm64
    $0 image list
    $0 purge --force
EOF
}

log() {
    echo "[$(date '+%H:%M:%S')] $*"
}

error() {
    echo "ERROR: $*" >&2
    exit 1
}

check_dependencies() {
    local missing=()
    for bin in "${REQUIRED_BINS[@]}"; do
        if ! command -v "$bin" >/dev/null 2>&1; then
            missing+=("$bin")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        # Check if brew is available
        if command -v brew >/dev/null 2>&1; then
            if brew install qemu >/dev/null 2>&1; then
                # Verify installation
                local still_missing=()
                for bin in "${REQUIRED_BINS[@]}"; do
                    if ! command -v "$bin" >/dev/null 2>&1; then
                        still_missing+=("$bin")
                    fi
                done
                
                if [[ ${#still_missing[@]} -gt 0 ]]; then
                    error "Installation failed. Still missing: ${still_missing[*]}"
                fi
            else
                error "Failed to install QEMU with brew. Please install manually: brew install qemu"
            fi
        else
            error "Missing dependencies: ${missing[*]}. Install Homebrew first, then run: brew install qemu"
        fi
    fi
}

generate_password() {
    local length=${1:-16}
    LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "$length"
}

find_free_port() {
    local preferred=$1
    
    # Function to check if a port is actually free and can be bound
    check_port_bindable() {
        local test_port=$1
        
        # First check with lsof (most reliable on macOS)
        if command -v lsof >/dev/null 2>&1; then
            if lsof -i ":$test_port" >/dev/null 2>&1; then
                return 1  # Port is in use
            fi
        fi
        
        # Also check with netstat
        if command -v netstat >/dev/null 2>&1; then
            if netstat -an 2>/dev/null | grep -q "\\.$test_port " || netstat -an 2>/dev/null | grep -q ":$test_port "; then
                return 1  # Port appears to be in use
            fi
        fi
        
        # Try to actually connect to the port to test if something is listening
        if command -v nc >/dev/null 2>&1; then
            # On macOS, nc might have different syntax - try both variants
            if nc -z 127.0.0.1 "$test_port" 2>/dev/null || nc -w 1 127.0.0.1 "$test_port" </dev/null >/dev/null 2>&1; then
                return 1  # Something is listening on the port
            fi
        fi
        
        return 0  # Port appears to be free
    }
    
    # Check preferred port first
    if [[ -n "$preferred" && "$preferred" -gt 0 ]]; then
        if check_port_bindable "$preferred"; then
            echo "$preferred"
            return
        fi
        log "Preferred port $preferred is in use, finding alternative..."
    fi
    
    # Find a free port in the range 2222-9999, but skip commonly used ports
    local skip_ports=(3000 3306 5432 5000 8000 8080 8443 9000)
    for port in $(seq 2222 9999); do
        # Skip commonly used ports
        local skip=false
        for skip_port in "${skip_ports[@]}"; do
            if [[ "$port" -eq "$skip_port" ]]; then
                skip=true
                break
            fi
        done
        [[ "$skip" == true ]] && continue
        
        if check_port_bindable "$port"; then
            echo "$port"
            return
        fi
    done
    
    error "No free port found in range 2222-9999"
}

download_image() {
    local image_name="$1"
    local arch="${2:-arm64}"
    local url
    url=$(get_image_url "$image_name" "$arch")
    
    if [[ -z "$url" ]]; then
        error "Unknown image: $image_name. Available: $(get_available_images)"
    fi
    
    local filename="${image_name}-${arch}.qcow2"
    local dest="$IMAGES_DIR/$filename"
    
    if [[ -f "$dest" ]]; then
        echo "$dest"
        return
    fi
    
    log "Downloading $image_name image..." >&2
    mkdir -p "$IMAGES_DIR"
    
    # Download to temporary file first
    local temp_file="$dest.tmp"
    if curl -L -s -f -o "$temp_file" "$url"; then
        # Verify the download completed successfully
        if [[ ! -s "$temp_file" ]]; then
            rm -f "$temp_file"
            error "Downloaded file is empty: $image_name"
        fi
        
        # Convert to qcow2 if needed
        if [[ "$url" == *.img ]]; then
            if qemu-img convert -O qcow2 "$temp_file" "$dest"; then
                rm "$temp_file"
                # Sync to ensure file is written to disk
                sync
            else
                rm -f "$temp_file" "$dest"
                error "Failed to convert image: $image_name"
            fi
        else
            if mv "$temp_file" "$dest"; then
                # Sync to ensure file is written to disk
                sync
            else
                rm -f "$temp_file"
                error "Failed to move image file: $image_name"
            fi
        fi
        
        # Verify the final image file is valid
        if ! qemu-img info "$dest" >/dev/null 2>&1; then
            rm -f "$dest"
            error "Downloaded image is not a valid QEMU image: $image_name"
        fi
        
        echo "$dest"
    else
        rm -f "$temp_file"
        error "Failed to download image: $image_name"
    fi
}

create_cloud_init() {
    local vm_dir="$1"
    local username="$2"
    local password="$3"
    local hostname="$4"
    local net_type="$5"
    local vm_ip="$6"
    
    local user_data=$(cat <<EOF
#cloud-config
datasource_list: [ NoCloud, None ]
final_message: "CLOUD-INIT-READY"
package_update: false
packages:
  - openssh-server
  - avahi-daemon
output:
  all: '| tee -a /var/log/cloud-init-output.log'
$([[ "$net_type" == "bridge" ]] && cat <<NETEOF
write_files:
  - path: /etc/systemd/system/systemd-networkd-wait-online.service.d/override.conf
    content: |
      [Service]
      ExecStart=
      ExecStart=/lib/systemd/systemd-networkd-wait-online --timeout=3
  - path: /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg
    content: |
      network: {config: disabled}
  - path: /etc/netplan/01-netcfg.yaml
    content: |
      network:
        version: 2
        renderer: networkd
        ethernets:
          enp0s1:
            dhcp4: no
            addresses:
              - $vm_ip/24
            routes:
              - to: 0.0.0.0/0
                via: 192.168.105.1
            nameservers:
              addresses: [8.8.8.8, 1.1.1.1]
NETEOF
)
users:
  - name: $username
    gecos: $username
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: [sudo]
    shell: /bin/bash
    lock_passwd: false
    plain_text_passwd: '$password'
ssh_pwauth: true
chpasswd:
  list: |
    $username:$password
  expire: false
write_files:
  - path: /etc/ssh/sshd_config.d/50-cloud-init.conf
    owner: root:root
    permissions: '0644'
    content: |
      PasswordAuthentication yes
      PubkeyAuthentication yes
      PermitRootLogin prohibit-password
      UseDNS no
      GSSAPIAuthentication no
runcmd:
  - echo "$username:$password" | chpasswd
  - passwd -u $username
  - systemctl enable ssh
  - systemctl enable avahi-daemon
  - |
    # Preserve SSH host keys across VM restarts
    if [ ! -f /etc/ssh/.keys_generated ]; then
      # Generate SSH host keys on first boot only
      ssh-keygen -A
      # Mark that keys have been generated to prevent regeneration
      touch /etc/ssh/.keys_generated
    fi
$([[ "$net_type" == "bridge" ]] && cat <<BRIDGECMD
  - mkdir -p /etc/systemd/system/systemd-networkd-wait-online.service.d
  - systemctl daemon-reload
  - netplan apply
BRIDGECMD
)
  - systemctl start ssh
  - systemctl start avahi-daemon
EOF
)
    
    local meta_data="{\"instance-id\": \"$hostname\", \"local-hostname\": \"$hostname\"}"
    local seed_iso="$vm_dir/seed.iso"
    
    # Create temporary directory for cloud-init files
    local tmpdir=$(mktemp -d)
    echo "$user_data" > "$tmpdir/user-data"
    echo "$meta_data" > "$tmpdir/meta-data"
    
    # Create ISO using hdiutil
    if hdiutil makehybrid -o "$seed_iso" -hfs -joliet -iso -default-volume-name "cidata" "$tmpdir" >/dev/null 2>&1; then
        rm -rf "$tmpdir"
        echo "$seed_iso"
        return
    fi
    
    # Fallback to mkisofs/genisoimage
    if command -v mkisofs >/dev/null 2>&1; then
        mkisofs -V cidata -o "$seed_iso" -J -r "$tmpdir"
    elif command -v genisoimage >/dev/null 2>&1; then
        genisoimage -V cidata -o "$seed_iso" -J -r "$tmpdir"
    else
        rm -rf "$tmpdir"
        error "Failed to create cloud-init ISO. Install mkisofs or genisoimage"
    fi
    
    rm -rf "$tmpdir"
    echo "$seed_iso"
}

detect_firmware() {
    local arch="${1:-arm64}"
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 doesn't need explicit BIOS path, uses default
        return 0
    fi
    
    # ARM64 firmware candidates
    local candidates=(
        "/opt/homebrew/share/qemu/edk2-aarch64-code.fd"
        "/usr/local/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/edk2/aarch64/QEMU_EFI.fd"
        "/usr/share/AAVMF/AAVMF_CODE.fd"
    )
    
    for firmware in "${candidates[@]}"; do
        if [[ -f "$firmware" ]]; then
            echo "$firmware"
            return
        fi
    done
    
    error "AArch64 UEFI firmware not found. Install with: brew install qemu"
}

wait_for_ssh() {
    local host="$1"
    local port="$2"
    local timeout=120
    local count=0
    
    while [[ $count -lt $timeout ]]; do
        if nc -z "$host" "$port" 2>/dev/null; then
            sleep 2  # Give SSH a moment to be fully ready
            if nc -z "$host" "$port" 2>/dev/null; then
                return 0
            fi
        fi
        sleep 1
        ((count++))
    done
    
    return 1
}

# Try to detect the IP address of a bridge mode VM
detect_bridge_vm_ip() {
    local vm_name="$1"
    local username="$2"
    
    # Method 1: Try to find by hostname (VM name)
    if command -v nslookup >/dev/null 2>&1; then
        local ip=$(nslookup "$vm_name.local" 2>/dev/null | grep -A1 "Name:" | tail -1 | awk '{print $2}')
        if [[ -n "$ip" && "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "$ip"
            return 0
        fi
    fi
    
    # Method 2: Try bridge network ranges and scan for SSH
    local common_ranges=(
        "192.168.100"  # Our bridge network
        "192.168.1"
        "192.168.0"
        "10.0.0"
        "172.16.0"
    )
    
    for range in "${common_ranges[@]}"; do
        # Quick scan for SSH on common IPs (this is a simplified approach)
        # Limit scan to reduce time
        local scan_range
        if [[ "$range" == "192.168.100" ]]; then
            scan_range="{10..50}"  # Our bridge network uses 10-50
        else
            scan_range="{100..150}"  # Other networks
        fi
        
        for i in $(eval echo $scan_range); do
            local test_ip="$range.$i"
            if nc -z -w1 "$test_ip" 22 2>/dev/null; then
                # Found SSH, but we need to verify it's our VM
                # This is a basic check - in practice you'd need more verification
                echo "$test_ip"
                return 0
            fi
        done
    done
    
    return 1
}

generate_mac_address() {
    local vm_name="$1"
    # Generate a deterministic MAC address based on VM name to ensure consistency
    # Use 52:54:00 prefix (QEMU's default) and generate last 3 octets from VM name hash
    local hash=$(echo -n "$vm_name" | shasum -a 256 | cut -c1-6)
    local mac="52:54:00"
    for i in {1..3}; do
        local byte="${hash:$((($i-1)*2)):2}"
        mac="$mac:$byte"
    done
    echo "$mac"
}

build_qemu_args() {
    local name="$1"
    local arch="$2"
    local memory="$3"
    local cpus="$4"
    local ssh_port="$5"
    local vm_disk="$6"
    local firmware="$7"
    local net_type="$8"
    
    # Generate unique MAC address for this VM
    local mac_addr=$(generate_mac_address "$name")
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 configuration
        echo "qemu-system-x86_64"
        echo "-machine" 
        echo "q35"
        echo "-cpu"
        echo "qemu64"
        echo "-m"
        echo "$memory"
        echo "-smp"
        echo "$cpus"
        echo "-object"
        echo "memory-backend-ram,id=mem,size=$memory"
        echo "-numa"
        echo "node,memdev=mem"
        echo "-name"
        echo "$name"
        echo "-device"
        echo "virtio-net-pci,netdev=n0,mac=$mac_addr"
        echo "-netdev"
        if [[ "$net_type" == "bridge" ]]; then
            echo "socket,id=n0,fd=3"
        else
            echo "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
        fi
        echo "-device"
        echo "virtio-rng-pci"
        echo "-drive"
        echo "file=$vm_disk,if=virtio,cache=writeback,format=qcow2"
    else
        # ARM64 configuration
        echo "qemu-system-aarch64"
        echo "-machine"
        echo "virt"
        echo "-cpu"
        echo "max"
        echo "-bios"
        echo "$firmware"
        echo "-m"
        echo "$memory"
        echo "-smp"
        echo "$cpus"
        echo "-name"
        echo "$name"
        echo "-device"
        echo "virtio-net-pci,netdev=n0,mac=$mac_addr"
        echo "-netdev"
        if [[ "$net_type" == "bridge" ]]; then
            echo "socket,id=n0,fd=3"
        else
            echo "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
        fi
        echo "-device"
        echo "virtio-rng-pci"
        echo "-drive"
        echo "file=$vm_disk,if=virtio,cache=writeback,format=qcow2"
    fi
}

# Image management functions
image_list() {
    echo
    printf "%-20s %-15s %-s\n" "IMAGE" "STATUS" "URL"
    printf "%-20s %-15s %-s\n" "-----" "------" "---"
    
    for image_name in $(get_available_images); do
        for arch in "arm64" "amd64"; do
            local filename="${image_name}-${arch}.qcow2"
            local image_path="$IMAGES_DIR/$filename"
            local status="AVAILABLE"
            
            if [[ -f "$image_path" ]]; then
                local size=$(du -h "$image_path" | cut -f1)
                status="DOWNLOADED ($size)"
            fi
            
            local url
            url=$(get_image_url "$image_name" "$arch")
            printf "%-20s %-15s %-s\n" "${image_name}-${arch}" "$status" "$url"
        done
    done
    echo
}

image_pull() {
    local image_spec="$1"
    [[ -z "$image_spec" ]] && error "Image name is required"
    
    local image_name arch
    
    # Parse image spec (e.g., "debian12-amd64" or "debian12")
    if [[ "$image_spec" =~ ^(.+)-(arm64|amd64)$ ]]; then
        image_name="${BASH_REMATCH[1]}"
        arch="${BASH_REMATCH[2]}"
    else
        image_name="$image_spec"
        arch="arm64"  # Default architecture
    fi
    
    local url
    url=$(get_image_url "$image_name" "$arch")
    if [[ -z "$url" ]]; then
        error "Unknown image: $image_name. Available: $(get_available_images)"
    fi
    
    download_image "$image_name" "$arch" >/dev/null
    log "Image ${image_name}-${arch} downloaded successfully"
}

image_delete() {
    local image_spec="$1"
    local force=false
    
    [[ -z "$image_spec" ]] && error "Image name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local image_name arch
    
    # Parse image spec (e.g., "debian12-amd64" or "debian12")
    if [[ "$image_spec" =~ ^(.+)-(arm64|amd64)$ ]]; then
        image_name="${BASH_REMATCH[1]}"
        arch="${BASH_REMATCH[2]}"
    else
        # If no architecture specified, show error with available options
        error "Please specify architecture. Example: $image_spec-arm64 or $image_spec-amd64"
    fi
    
    local filename="${image_name}-${arch}.qcow2"
    local image_path="$IMAGES_DIR/$filename"
    
    if [[ ! -f "$image_path" ]]; then
        error "Image ${image_name}-${arch} is not downloaded"
    fi
    
    # Note: VMs have their own independent disk copies, so base images can always be deleted
    
    # Confirm deletion
    if [[ "$force" == false ]]; then
        echo "This will permanently delete the downloaded image '${image_name}-${arch}'."
        read -p "Are you sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Deletion cancelled"
            return
        fi
    fi
    
    rm -f "$image_path"
    log "Image ${image_name}-${arch} deleted successfully"
}

# VM management functions
vm_create() {
    local name=""
    local image=""
    local arch="arm64"
    local username="$DEFAULT_USERNAME"
    local password=""
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    local disk="$DEFAULT_DISK"
    local ssh_port=""
    local net_type="bridge"
    local show_console=false
    local debug=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                name="$2"
                shift 2
                ;;
            --image)
                image="$2"
                shift 2
                ;;
            --arch)
                arch="$2"
                shift 2
                ;;
            --user)
                username="$2"
                shift 2
                ;;
            --pass)
                password="$2"
                shift 2
                ;;
            --memory)
                memory="$2"
                shift 2
                ;;
            --cpus)
                cpus="$2"
                shift 2
                ;;
            --disk)
                disk="$2"
                shift 2
                ;;
            --ssh-port)
                ssh_port="$2"
                shift 2
                ;;
            --net-type)
                net_type="$2"
                if [[ "$net_type" != "bridge" && "$net_type" != "portfwd" ]]; then
                    error "Invalid network type: $net_type. Valid options: bridge, portfwd"
                fi
                shift 2
                ;;
            --show-console)
                show_console=true
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    [[ -z "$name" ]] && error "--name is required"
    [[ -z "$image" ]] && image="debian12"
    
    # Validate architecture
    if [[ "$arch" != "arm64" && "$arch" != "amd64" && "$arch" != "x86_64" ]]; then
        error "Invalid architecture: $arch. Options: arm64, amd64"
    fi
    
    # Normalize architecture
    [[ "$arch" == "x86_64" ]] && arch="amd64"
    
    [[ -z "$password" ]] && password=$(generate_password 16)
    [[ -z "$ssh_port" ]] && ssh_port=$(find_free_port)
    
    local vm_dir="$VMS_DIR/$name"
    
    # Check if VM already exists
    if [[ -d "$vm_dir" ]]; then
        local info_file="$vm_dir/info.json"
        if [[ -f "$info_file" ]]; then
            log "VM '$name' already exists. Checking if it's running..."
            local pid_file="$vm_dir/qemu.pid"
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file" 2>/dev/null)
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    local existing_port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
                    local existing_user=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
                    local existing_pass=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
                    error "VM '$name' is already running on port $existing_port (user: $existing_user, pass: $existing_pass)"
                fi
            fi
            log "VM directory exists but VM is not running. Recreating..."
        fi
    fi
    
    mkdir -p "$vm_dir"
    
    log "Creating VM: $name"
    
    # Download base image
    local base_image
    base_image=$(download_image "$image" "$arch")
    
    # Create VM disk
    local vm_disk="$vm_dir/disk.qcow2"
    if [[ ! -f "$vm_disk" ]]; then
        log "Creating VM disk from base image..." >&2
        if qemu-img convert -O qcow2 "$base_image" "$vm_disk"; then
            if qemu-img resize "$vm_disk" "$disk" >/dev/null; then
                # Sync to ensure VM disk is written to disk
                sync
                # Verify the VM disk is valid
                if ! qemu-img info "$vm_disk" >/dev/null 2>&1; then
                    rm -f "$vm_disk"
                    error "Failed to create valid VM disk for: $name"
                fi
                log "VM disk created successfully" >&2
            else
                rm -f "$vm_disk"
                error "Failed to resize VM disk for: $name"
            fi
        else
            rm -f "$vm_disk"
            error "Failed to create VM disk from base image for: $name"
        fi
    fi
    
    # Create cloud-init seed
    local seed_iso vm_static_ip
    if [[ "$net_type" == "bridge" ]]; then
        # Generate static IP for bridge mode - check for conflicts
        local random_ip
        local max_attempts=50
        local attempt=0
        
        while [[ $attempt -lt $max_attempts ]]; do
            random_ip=$((RANDOM % 90 + 10))
            vm_static_ip="192.168.105.$random_ip"
            
            # Check if IP is already in use by another VM
            if ! grep -r "\"bridge_ip\": \"$vm_static_ip\"" "$VMS_DIR"/*/info.json >/dev/null 2>&1; then
                # Also ping test to check if IP is in use on network
                if ! ping -c 1 -W 300 "$vm_static_ip" >/dev/null 2>&1; then
                    break
                fi
            fi
            ((attempt++))
        done
        
        if [[ $attempt -eq $max_attempts ]]; then
            error "Could not find available IP address in range 192.168.105.10-99"
        fi
    fi
    seed_iso=$(create_cloud_init "$vm_dir" "$username" "$password" "$name" "$net_type" "$vm_static_ip")
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Save VM info
    local info_json="$vm_dir/info.json"
    if [[ "$net_type" == "bridge" ]]; then
        cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$image",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "bridge_ip": "$vm_static_ip",
  "ssh": {
    "host": "$vm_static_ip",
    "port": 22
  }
}
EOF
    else
        cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$image",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    while IFS= read -r line; do
        qemu_args+=("$line")
    done < <(build_qemu_args "$name" "$arch" "$memory" "$cpus" "$ssh_port" "$vm_disk" "$firmware" "$net_type")
    
    # Add cloud-init for first boot only
    local first_boot_marker="$vm_dir/.first_boot_complete"
    qemu_args+=("-cdrom" "$seed_iso")
    
    # Add acceleration if available (only for ARM64 on macOS)
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Show debug information if requested
    if [[ "$debug" == true ]]; then
        echo "=== DEBUG INFO ==="
        echo "VM Name: $name"
        echo "Architecture: $arch"
        echo "Memory: $memory"
        echo "CPUs: $cpus"
        echo "Network Type: $net_type"
        echo "SSH Port: $ssh_port"
        echo "VM Disk: $vm_disk"
        echo "Seed ISO: $seed_iso"
        [[ -n "$firmware" ]] && echo "Firmware: $firmware"
        echo
        echo "QEMU Command:"
        printf "%s " "${qemu_args[@]}"
        echo
        echo "=================="
        echo
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        log "Starting VM with console (Ctrl+A then X to quit)"
        log "Credentials: $username / $password"
        if [[ "$net_type" == "bridge" ]]; then
            log "Network: Bridged mode (find VM IP with ping/nmap)"
        else
            log "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        fi
        read -p "Press Enter to start..."
        if [[ "$net_type" == "bridge" ]]; then
            exec /opt/homebrew/opt/socket_vmnet/bin/socket_vmnet_client /opt/homebrew/var/run/socket_vmnet "${qemu_args[@]}"
        else
            exec "${qemu_args[@]}"
        fi
    else
        local console_log="$vm_dir/console.log"
        local pid_file="$vm_dir/qemu.pid"
        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "none"
            "-pidfile" "$pid_file"
        )
        
        # Try to start QEMU, with retry logic for port conflicts
        local max_retries=5
        local retry_count=0
        
        while [[ $retry_count -lt $max_retries ]]; do
            if [[ "$net_type" == "bridge" ]]; then
                if /opt/homebrew/opt/socket_vmnet/bin/socket_vmnet_client /opt/homebrew/var/run/socket_vmnet "${qemu_args[@]}" 2>/dev/null; then
                    break
                else
                    local qemu_error=$?
                    log "QEMU failed to start (exit code: $qemu_error)"
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -ge $max_retries ]]; then
                        error "Failed to start QEMU after $max_retries attempts"
                    else
                        log "Retrying QEMU start..."
                        sleep 1
                    fi
                fi
            else
                if "${qemu_args[@]}" 2>/dev/null; then
                    break
                else
                    local qemu_error=$?
                    log "QEMU failed to start (exit code: $qemu_error)"
                    
                    # Check if it's likely a port conflict (only for portfwd mode)
                    retry_count=$((retry_count + 1))
                        if [[ $retry_count -lt $max_retries ]]; then
                            log "Attempting retry $retry_count/$max_retries with a different port..."
                            
                            # Find a new port
                            ssh_port=$(find_free_port)
                            log "Trying new SSH port: $ssh_port"
                            
                            # Update the QEMU args with new port
                            for i in "${!qemu_args[@]}"; do
                                if [[ "${qemu_args[i]}" =~ ^user,id=n0,hostfwd=tcp:127\.0\.0\.1:[0-9]+-:22$ ]]; then
                                    qemu_args[i]="user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
                                    break
                                fi
                            done
                            
                            # Update the info JSON
                            cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$image",
  "username": "$username",
  "password": "$password",
  "net_type": "$net_type",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
                            
                            sleep 1
                        else
                            error "Failed to start QEMU after $max_retries attempts"
                        fi
                fi
            fi
        done
        
        # Wait for SSH
        if [[ "$net_type" == "bridge" ]]; then
            # For bridge mode, we don't have direct SSH access via port forwarding
            # Mark first boot as complete immediately
            touch "$first_boot_marker"
            log "VM $name is ready with bridge networking!"
            echo
            echo "Network mode: VMNet Shared Bridge"
            echo "VM has internet access and shares host network"
            echo "VM IP: $vm_static_ip (static IP with modern netplan)"
            echo "Credentials: $username / $password"
            echo "Note: SSH with: ssh $username@$vm_static_ip"
        else
            if wait_for_ssh "127.0.0.1" "$ssh_port"; then
                # Mark first boot as complete after successful SSH connection
                touch "$first_boot_marker"
                log "VM $name is ready, just wait some second to ssh service to be available!"
                echo
                echo "Connect with: ssh $username@127.0.0.1 -p $ssh_port"
                echo "Password: $password"
                #echo "Console log: $console_log"
            else
                log "VM started but SSH is not responding"
                #echo "Check console log: $console_log"
            fi
        fi
    fi
}

vm_list() {
    if [[ ! -d "$VMS_DIR" ]]; then
        log "No VMs found (VMs directory doesn't exist)"
        return
    fi
    
    local vm_count=0
    echo
    printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "NAME" "STATUS" "ARCH" "IMAGE" "ADDRESS" "CREDENTIALS"
    printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "----" "------" "----" "-----" "-------" "-----------"
    
    for vm_dir in "$VMS_DIR"/*; do
        if [[ ! -d "$vm_dir" ]]; then
            continue
        fi
        
        local vm_name=$(basename "$vm_dir")
        local info_file="$vm_dir/info.json"
        local pid_file="$vm_dir/qemu.pid"
        
        if [[ ! -f "$info_file" ]]; then
            printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "$vm_name" "BROKEN" "-" "-" "-" "-"
            ((vm_count++))
            continue
        fi
        
        local status="STOPPED"
        local ssh_info="-"
        local credentials="-"
        
        # Check if VM is running
        local is_running=false
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                is_running=true
            else
                # Clean up stale PID file
                rm -f "$pid_file"
            fi
        fi
        
        # Fallback check: look for running QEMU process with this VM name
        # This handles cases where VMs were started with --show-console (no PID file)
        if [[ "$is_running" == "false" ]]; then
            if pgrep -f "qemu.*-name $vm_name" >/dev/null 2>&1; then
                is_running=true
            fi
        fi
        
        if [[ "$is_running" == "true" ]]; then
            status="RUNNING"
            
            # Extract info from JSON
            local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
            local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)
            
            # Default to portfwd if net_type is not found (for backward compatibility with existing VMs)
            [[ -z "$net_type" ]] && net_type="portfwd"
            
            if [[ "$net_type" == "bridge" ]]; then
                # For bridge mode, show the static bridge IP
                local bridge_ip=$(grep -o '"bridge_ip": "[^"]*"' "$info_file" | cut -d'"' -f4)
                ssh_info="${bridge_ip:-bridge (use 'vm ip $vm_name')}"
            else
                ssh_info="127.0.0.1:$port"
            fi
            credentials="$username:$password"
        fi
        
        # Get info from JSON file
        local arch=$(grep -o '"arch": "[^"]*"' "$info_file" | cut -d'"' -f4)
        local image=$(grep -o '"image": "[^"]*"' "$info_file" | cut -d'"' -f4)
        
        printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "$vm_name" "$status" "${arch:-arm64}" "${image:-unknown}" "$ssh_info" "$credentials"
        ((vm_count++))
    done
    
    if [[ $vm_count -eq 0 ]]; then
        echo "No VMs found"
    else
        echo
        echo "Total VMs: $vm_count"
    fi
}

vm_start() {
    local name="$1"
    local show_console=false
    local debug=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --show-console)
                show_console=true
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    local pid_file="$vm_dir/qemu.pid"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]] || [[ ! -f "$info_file" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if already running
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
            local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
            error "VM '$name' is already running on port $port (user: $username, pass: $password)"
        fi
        # Clean up stale PID file
        rm -f "$pid_file"
    fi
    
    log "Starting VM: $name"
    
    # Extract VM info
    local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local ssh_port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
    local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)
    
    # Default to portfwd if net_type is not found (for backward compatibility with existing VMs)
    [[ -z "$net_type" ]] && net_type="portfwd"
    
    # Find a free port if the saved one is in use
    port_check_function() {
        local test_port=$1
        
        # First check with lsof
        if command -v lsof >/dev/null 2>&1; then
            if lsof -i ":$test_port" >/dev/null 2>&1; then
                return 1
            fi
        fi
        
        # Also check with netstat
        if command -v netstat >/dev/null 2>&1; then
            if netstat -an 2>/dev/null | grep -q "\\.$test_port " || netstat -an 2>/dev/null | grep -q ":$test_port "; then
                return 1
            fi
        fi
        
        return 0
    }
    
    if ! port_check_function "$ssh_port"; then
        log "Saved SSH port $ssh_port is in use, finding new port..."
        ssh_port=$(find_free_port)
        log "Using new SSH port: $ssh_port"
        
        # Update info.json with new port
        local temp_json=$(mktemp)
        sed "s/\"port\": [0-9]*/\"port\": $ssh_port/" "$info_file" > "$temp_json"
        mv "$temp_json" "$info_file"
    fi
    
    # Get VM files
    local vm_disk="$vm_dir/disk.qcow2"
    local seed_iso="$vm_dir/seed.iso"
    
    if [[ ! -f "$vm_disk" ]]; then
        error "VM disk not found: $vm_disk"
    fi
    
    # Get architecture from VM info
    local arch=$(grep -o '"arch": "[^"]*"' "$info_file" | cut -d'"' -f4)
    [[ -z "$arch" ]] && arch="arm64"  # Default to arm64 for backward compatibility
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    while IFS= read -r line; do
        qemu_args+=("$line")
    done < <(build_qemu_args "$name" "$arch" "$memory" "$cpus" "$ssh_port" "$vm_disk" "$firmware" "$net_type")
    
    # Only add cloud-init for fresh VMs (check if this is first boot)
    # We determine this by checking if the VM has been booted before
    local first_boot_marker="$vm_dir/.first_boot_complete"
    if [[ -f "$seed_iso" ]] && [[ ! -f "$first_boot_marker" ]]; then
        qemu_args+=("-cdrom" "$seed_iso")
    fi
    
    # Add acceleration if available (only for ARM64 on macOS)
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Show debug information if requested
    if [[ "$debug" == true ]]; then
        echo "=== DEBUG INFO (VM START) ==="
        echo "VM Name: $name"
        echo "Architecture: $arch"
        echo "Network Type: $net_type"
        echo "SSH Port: $ssh_port"
        echo "VM Disk: $vm_disk"
        [[ -f "$seed_iso" && ! -f "$first_boot_marker" ]] && echo "Seed ISO: $seed_iso (first boot)"
        [[ -n "$firmware" ]] && echo "Firmware: $firmware"
        echo
        echo "QEMU Command:"
        printf "%s " "${qemu_args[@]}"
        echo
        echo "============================="
        echo
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        log "Starting VM with console (Ctrl+A then X to quit)"
        log "Credentials: $username / $password"
        if [[ "$net_type" == "bridge" ]]; then
            log "Network: Bridged mode (find VM IP with ping/nmap)"
        else
            log "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        fi
        read -p "Press Enter to start..."
        if [[ "$net_type" == "bridge" ]]; then
            exec /opt/homebrew/opt/socket_vmnet/bin/socket_vmnet_client /opt/homebrew/var/run/socket_vmnet "${qemu_args[@]}"
        else
            exec "${qemu_args[@]}"
        fi
    else
        local console_log="$vm_dir/console.log"
        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "none"
            "-pidfile" "$pid_file"
        )
        
        if [[ "$net_type" == "bridge" ]]; then
            bridge_success=0
            if /opt/homebrew/opt/socket_vmnet/bin/socket_vmnet_client /opt/homebrew/var/run/socket_vmnet "${qemu_args[@]}" 2>/dev/null; then
                bridge_success=0
            else
                bridge_success=1
            fi
        else
            bridge_success=0
            if "${qemu_args[@]}" 2>/dev/null; then
                bridge_success=0
            else
                bridge_success=1
            fi
        fi
        if [[ $bridge_success -eq 0 ]]; then
            if [[ "$net_type" == "bridge" ]]; then
                # For bridge mode, we can't wait for SSH on localhost port
                # Mark first boot as complete immediately
                if [[ ! -f "$first_boot_marker" ]]; then
                    touch "$first_boot_marker"
                fi
                log "VM $name is ready with bridge networking!"
                echo
                echo "Network mode: VMNet Shared Bridge"
                echo "VM IP: $vm_static_ip (static IP with modern netplan)"
                echo "Credentials: $username / $password"
                echo "Console log: $console_log"
                echo "Note: SSH with: ssh $username@$vm_static_ip"
            else
                if wait_for_ssh "127.0.0.1" "$ssh_port"; then
                    # Mark first boot as complete after successful SSH connection (if it was first boot)
                    if [[ ! -f "$first_boot_marker" ]]; then
                        touch "$first_boot_marker"
                    fi
                    log "VM is ready!"
                    echo
                    echo "Connect with: ssh $username@127.0.0.1 -p $ssh_port"
                    echo "Password: $password"
                    echo "Console log: $console_log"
                else
                    log "VM started but SSH is not responding"
                    echo "Check console log: $console_log"
                fi
            fi
        else
            error "Failed to start VM"
        fi
    fi
}

vm_stop() {
    local name="$1"
    
    [[ -z "$name" ]] && error "VM name is required"
    
    local vm_dir="$VMS_DIR/$name"
    local pid_file="$vm_dir/qemu.pid"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if VM is running - first check PID file, then fallback to process search
    local pid=""
    if [[ -f "$pid_file" ]]; then
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            log "VM '$name' is not running (cleaning up stale PID file)"
            rm -f "$pid_file"
            pid=""
        fi
    fi
    
    # Fallback: look for running QEMU process if no valid PID found
    if [[ -z "$pid" ]]; then
        pid=$(pgrep -f "qemu.*-name $name" | head -1)
        if [[ -z "$pid" ]]; then
            log "VM '$name' is not running"
            return
        fi
    fi
    
    log "Stopping VM: $name (PID: $pid)"
    
    # Try graceful shutdown first
    if kill -TERM "$pid" 2>/dev/null; then
        local count=0
        local timeout=30
        
        log "Sending graceful shutdown signal..."
        while [[ $count -lt $timeout ]] && kill -0 "$pid" 2>/dev/null; do
            sleep 1
            ((count++))
        done
        
        if kill -0 "$pid" 2>/dev/null; then
            log "Graceful shutdown timed out, forcing stop..."
            kill -KILL "$pid" 2>/dev/null
            sleep 2
        fi
        
        if ! kill -0 "$pid" 2>/dev/null; then
            log "VM stopped successfully"
            rm -f "$pid_file"
        else
            error "Failed to stop VM"
        fi
    else
        error "Failed to send stop signal to VM"
    fi
}

vm_ip() {
    local name="$1"
    
    [[ -z "$name" ]] && error "VM name is required"
    
    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]] || [[ ! -f "$info_file" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check network type
    local net_type=$(grep -o '"net_type": "[^"]*"' "$info_file" | cut -d'"' -f4)
    [[ -z "$net_type" ]] && net_type="portfwd"
    
    if [[ "$net_type" != "bridge" ]]; then
        local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
        echo "VM '$name' uses port forwarding: ssh user@127.0.0.1 -p $port"
        return
    fi
    
    # Check if VM is running
    local pid_file="$vm_dir/qemu.pid"
    if [[ ! -f "$pid_file" ]]; then
        echo "VM '$name' is not running"
        return
    fi
    
    local pid=$(cat "$pid_file" 2>/dev/null)
    if [[ -z "$pid" ]] || ! kill -0 "$pid" 2>/dev/null; then
        echo "VM '$name' is not running"
        return
    fi
    
    local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
    
    echo "Searching for IP address of bridge VM '$name'..."
    echo "This may take a moment..."
    
    local detected_ip
    if detected_ip=$(detect_bridge_vm_ip "$name" "$username"); then
        echo "Found IP: $detected_ip"
        echo "Connect with: ssh $username@$detected_ip"
        local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
        echo "Password: $password"
    else
        echo "Could not automatically detect IP address."
        echo "Try these methods:"
        echo "1. Check your router's DHCP client list"
        echo "2. Use nmap: nmap -sn 192.168.1.0/24 (adjust network range)"
        echo "3. Use arp: arp -a | grep -i \"$(echo "$name" | cut -c1-6)\""
        echo "4. Check console log: cat $vm_dir/console.log | grep -i ip"
    fi
}

vm_delete() {
    local name="$1"
    local force=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if VM is running and stop it
    local pid_file="$vm_dir/qemu.pid"
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log "Stopping running VM before deletion..."
            vm_stop "$name"
        fi
    fi
    
    # Confirm deletion
    if [[ "$force" == false ]]; then
        echo "This will permanently delete VM '$name' and all its data."
        read -p "Are you sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Deletion cancelled"
            return
        fi
    fi
    
    log "Deleting VM: $name"
    rm -rf "$vm_dir"
    log "VM '$name' deleted successfully"
}

purge() {
    local force=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    # Count what will be deleted
    local vm_count=0
    local image_count=0
    
    # Count VMs
    if [[ -d "$VMS_DIR" ]]; then
        for vm_dir in "$VMS_DIR"/*; do
            if [[ -d "$vm_dir" ]]; then
                ((vm_count++))
            fi
        done
    fi
    
    # Count downloaded images
    if [[ -d "$IMAGES_DIR" ]]; then
        for image_file in "$IMAGES_DIR"/*.qcow2; do
            if [[ -f "$image_file" ]]; then
                ((image_count++))
            fi
        done
    fi
    
    # Show what will be deleted
    if [[ $vm_count -eq 0 && $image_count -eq 0 ]]; then
        log "Nothing to purge - no VMs or downloaded images found"
        return
    fi
    
    log "Purge will delete:"
    [[ $vm_count -gt 0 ]] && log "  - $vm_count VM(s) and their data"
    [[ $image_count -gt 0 ]] && log "  - $image_count downloaded image(s)"
    
    # Confirm purge
    if [[ "$force" == false ]]; then
        echo
        echo "WARNING: This will permanently delete ALL VMs and downloaded images!"
        echo "This action cannot be undone."
        read -p "Are you absolutely sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Purge cancelled"
            return
        fi
    fi
    
    log "Starting purge operation..."
    
    # Stop and delete all VMs
    if [[ $vm_count -gt 0 ]]; then
        log "Deleting $vm_count VMs..."
        for vm_dir in "$VMS_DIR"/*; do
            if [[ -d "$vm_dir" ]]; then
                local vm_name=$(basename "$vm_dir")
                log "  Deleting VM: $vm_name"
                
                # Stop VM if running
                local pid_file="$vm_dir/qemu.pid"
                if [[ -f "$pid_file" ]]; then
                    local pid=$(cat "$pid_file" 2>/dev/null)
                    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                        log "    Stopping running VM..."
                        kill -TERM "$pid" 2>/dev/null || true
                        sleep 2
                        kill -KILL "$pid" 2>/dev/null || true
                    fi
                fi
                
                # Delete VM directory
                rm -rf "$vm_dir"
            fi
        done
        
        # Remove empty VMs directory
        [[ -d "$VMS_DIR" && -z "$(ls -A "$VMS_DIR" 2>/dev/null)" ]] && rmdir "$VMS_DIR"
    fi
    
    # Delete all downloaded images
    if [[ $image_count -gt 0 ]]; then
        log "Deleting $image_count downloaded images..."
        for image_file in "$IMAGES_DIR"/*.qcow2; do
            if [[ -f "$image_file" ]]; then
                local image_name=$(basename "$image_file")
                log "  Deleting image: $image_name"
                rm -f "$image_file"
            fi
        done
        
        # Remove empty images directory
        [[ -d "$IMAGES_DIR" && -z "$(ls -A "$IMAGES_DIR" 2>/dev/null)" ]] && rmdir "$IMAGES_DIR"
    fi
    
    # Remove empty root directory if both subdirs are gone
    if [[ -d "$WORK_ROOT" && -z "$(ls -A "$WORK_ROOT" 2>/dev/null)" ]]; then
        rmdir "$WORK_ROOT"
    fi
    
    log "Purge completed successfully!"
    log "Deleted $vm_count VM(s) and $image_count image(s)"
}

vm_help() {
    cat <<EOF
VM Commands Help:

USAGE:
    $0 vm COMMAND [options]

COMMANDS:
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM  
    delete VM_NAME      Delete a VM and its files
    ip VM_NAME          Try to find IP address of a bridge mode VM
    help                Show this help message

CREATE OPTIONS:
    --name NAME         VM name (required)
    --image IMAGE       Base image (default: debian12)
    --arch ARCH         Architecture: arm64, amd64 (default: arm64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --net-type TYPE     Network type (default: bridge, options: bridge, portfwd)
    --show-console      Show console output
    --debug             Show debug information including QEMU command

START OPTIONS:
    --show-console      Show console output
    --debug             Show debug information including QEMU command

DELETE OPTIONS:
    --force             Delete without confirmation

EXAMPLES:
    $0 vm create --name myvm
    $0 vm create --name myvm --arch amd64 --memory 4G --net-type portfwd --cpus 4
    $0 vm create --name myvm --image debian12 --user admin --pass mypass
    $0 vm list
    $0 vm start myvm
    $0 vm start myvm --show-console
    $0 vm stop myvm
    $0 vm ip myvm
    $0 vm delete myvm
    $0 vm delete myvm --force

NOTES:
    - VMs have independent disk copies, so deleting base images won't affect running VMs
    - ARM64 VMs use HVF acceleration on macOS, x86_64 VMs run in emulation mode
    - SSH credentials are shown after VM creation and in 'vm list' output
EOF
}

image_help() {
    cat <<EOF
Image Commands Help:

USAGE:
    $0 image COMMAND [options]

COMMANDS:
    list                List available and downloaded images
    pull IMAGE_NAME     Download an image
    delete IMAGE_NAME   Delete a downloaded image  
    help                Show this help message

AVAILABLE IMAGES:
    debian12-arm64      Debian 12 for ARM64 architecture
    debian12-amd64      Debian 12 for x86_64 architecture

DELETE OPTIONS:
    --force             Delete without confirmation

EXAMPLES:
    $0 image list
    $0 image pull debian12-arm64
    $0 image pull debian12-amd64
    $0 image delete debian12-arm64
    $0 image delete debian12-amd64 --force

NOTES:
    - Images are downloaded to ~/.linux/images/
    - Each VM creates its own independent disk copy from base images
    - Base images can be safely deleted after VM creation to save space
    - Images are automatically downloaded when creating VMs if not present
EOF
}

main() {
    local entity="${1:-}"
    local command="${2:-}"
    
    case "$entity" in
        vm)
            shift
            [[ $# -gt 0 ]] && shift
            case "$command" in
                create)
                    check_dependencies
                    mkdir -p "$IMAGES_DIR" "$VMS_DIR"
                    vm_create "$@"
                    ;;
                list)
                    mkdir -p "$VMS_DIR"
                    vm_list
                    ;;
                start)
                    check_dependencies
                    vm_start "$@"
                    ;;
                stop)
                    vm_stop "$@"
                    ;;
                delete)
                    vm_delete "$@"
                    ;;
                ip)
                    vm_ip "$@"
                    ;;
                help|--help|-h|"")
                    vm_help
                    ;;
                *)
                    error "Unknown VM command: $command"
                    ;;
            esac
            ;;
        image)
            shift
            [[ $# -gt 0 ]] && shift
            case "$command" in
                list)
                    mkdir -p "$IMAGES_DIR"
                    image_list
                    ;;
                pull)
                    check_dependencies
                    mkdir -p "$IMAGES_DIR"
                    image_pull "$@"
                    ;;
                delete)
                    image_delete "$@"
                    ;;
                help|--help|-h|"")
                    image_help
                    ;;
                *)
                    error "Unknown image command: $command"
                    ;;
            esac
            ;;
        purge)
            shift 1
            purge "$@"
            ;;
        --help|-h|help|"")
            usage
            ;;
        *)
            error "Unknown entity: $entity"
            ;;
    esac
}

main "$@"