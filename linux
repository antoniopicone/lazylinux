#!/bin/bash

set -e

# Configuration
WORK_ROOT="$HOME/.linux_vm_cli"
IMAGES_DIR="$WORK_ROOT/images"
VMS_DIR="$WORK_ROOT/vms"
DEFAULT_USERNAME="user01"
DEFAULT_MEMORY="2G"
DEFAULT_CPUS="2"
DEFAULT_DISK="10G"

get_image_url() {
    local image_name="$1"
    local arch="${2:-arm64}"
    
    case "$image_name" in
        debian12)
            if [[ "$arch" == "amd64" || "$arch" == "x86_64" ]]; then
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
            else
                echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-arm64.qcow2"
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

get_available_images() {
    echo "debian12 ubuntu22 ubuntu24"
}

# Required binaries
REQUIRED_BINS=(
    "qemu-system-aarch64"
    "qemu-system-x86_64"
    "qemu-img"
    "hdiutil"
)

usage() {
    cat <<EOF
Usage: $0 ENTITY COMMAND [options]

Entities:
    vm                  Virtual machine operations
    image               Image management operations

VM Commands:
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM
    delete VM_NAME      Delete a VM and its files
    help                Show detailed VM help

Image Commands:
    list                List available and downloaded images
    pull IMAGE_NAME     Download an image (e.g., debian12-arm64, debian12-amd64)
    delete IMAGE_NAME   Delete a downloaded image (e.g., debian12-arm64)
                        --force         Delete without confirmation
    help                Show detailed image help

System Commands:
    purge               Delete all VMs and downloaded images
                        --force         Purge without confirmation

VM Create options:
    --name NAME         VM name (required)
    --image IMAGE       Base image (default: debian12, options: debian12, ubuntu22, ubuntu24)
    --arch ARCH         Architecture (default: arm64, options: arm64, amd64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --show-console      Show console output

Examples:
    $0 vm help                    # Show detailed VM help
    $0 image help                 # Show detailed image help
    $0 vm create --name myvm --arch amd64 --memory 4G
    $0 vm list
    $0 vm start myvm
    $0 image pull debian12-arm64
    $0 image list
    $0 purge --force
EOF
}

log() {
    echo "[$(date '+%H:%M:%S')] $*"
}

error() {
    echo "ERROR: $*" >&2
    exit 1
}

check_dependencies() {
    local missing=()
    for bin in "${REQUIRED_BINS[@]}"; do
        if ! command -v "$bin" >/dev/null 2>&1; then
            missing+=("$bin")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        # Check if brew is available
        if command -v brew >/dev/null 2>&1; then
            if brew install qemu >/dev/null 2>&1; then
                # Verify installation
                local still_missing=()
                for bin in "${REQUIRED_BINS[@]}"; do
                    if ! command -v "$bin" >/dev/null 2>&1; then
                        still_missing+=("$bin")
                    fi
                done
                
                if [[ ${#still_missing[@]} -gt 0 ]]; then
                    error "Installation failed. Still missing: ${still_missing[*]}"
                fi
            else
                error "Failed to install QEMU with brew. Please install manually: brew install qemu"
            fi
        else
            error "Missing dependencies: ${missing[*]}. Install Homebrew first, then run: brew install qemu"
        fi
    fi
}

generate_password() {
    local length=${1:-16}
    LC_ALL=C tr -dc 'A-Za-z0-9' </dev/urandom | head -c "$length"
}

find_free_port() {
    local preferred=$1
    
    # Function to check if a port is actually free and can be bound
    check_port_bindable() {
        local test_port=$1
        
        # First check with lsof (most reliable on macOS)
        if command -v lsof >/dev/null 2>&1; then
            if lsof -i ":$test_port" >/dev/null 2>&1; then
                return 1  # Port is in use
            fi
        fi
        
        # Also check with netstat
        if command -v netstat >/dev/null 2>&1; then
            if netstat -an 2>/dev/null | grep -q "\\.$test_port " || netstat -an 2>/dev/null | grep -q ":$test_port "; then
                return 1  # Port appears to be in use
            fi
        fi
        
        # Try to actually connect to the port to test if something is listening
        if command -v nc >/dev/null 2>&1; then
            # On macOS, nc might have different syntax - try both variants
            if nc -z 127.0.0.1 "$test_port" 2>/dev/null || nc -w 1 127.0.0.1 "$test_port" </dev/null >/dev/null 2>&1; then
                return 1  # Something is listening on the port
            fi
        fi
        
        return 0  # Port appears to be free
    }
    
    # Check preferred port first
    if [[ -n "$preferred" && "$preferred" -gt 0 ]]; then
        if check_port_bindable "$preferred"; then
            echo "$preferred"
            return
        fi
        log "Preferred port $preferred is in use, finding alternative..."
    fi
    
    # Find a free port in the range 2222-9999, but skip commonly used ports
    local skip_ports=(3000 3306 5432 5000 8000 8080 8443 9000)
    for port in $(seq 2222 9999); do
        # Skip commonly used ports
        local skip=false
        for skip_port in "${skip_ports[@]}"; do
            if [[ "$port" -eq "$skip_port" ]]; then
                skip=true
                break
            fi
        done
        [[ "$skip" == true ]] && continue
        
        if check_port_bindable "$port"; then
            echo "$port"
            return
        fi
    done
    
    error "No free port found in range 2222-9999"
}

download_image() {
    local image_name="$1"
    local arch="${2:-arm64}"
    local url
    url=$(get_image_url "$image_name" "$arch")
    
    if [[ -z "$url" ]]; then
        error "Unknown image: $image_name. Available: $(get_available_images)"
    fi
    
    local filename="${image_name}-${arch}.qcow2"
    local dest="$IMAGES_DIR/$filename"
    
    if [[ -f "$dest" ]]; then
        echo "$dest"
        return
    fi
    
    log "Downloading $image_name image..." >&2
    mkdir -p "$IMAGES_DIR"
    
    # Download to temporary file first
    local temp_file="$dest.tmp"
    if curl -L -s -f -o "$temp_file" "$url"; then
        # Verify the download completed successfully
        if [[ ! -s "$temp_file" ]]; then
            rm -f "$temp_file"
            error "Downloaded file is empty: $image_name"
        fi
        
        # Convert to qcow2 if needed
        if [[ "$url" == *.img ]]; then
            if qemu-img convert -O qcow2 "$temp_file" "$dest"; then
                rm "$temp_file"
                # Sync to ensure file is written to disk
                sync
            else
                rm -f "$temp_file" "$dest"
                error "Failed to convert image: $image_name"
            fi
        else
            if mv "$temp_file" "$dest"; then
                # Sync to ensure file is written to disk
                sync
            else
                rm -f "$temp_file"
                error "Failed to move image file: $image_name"
            fi
        fi
        
        # Verify the final image file is valid
        if ! qemu-img info "$dest" >/dev/null 2>&1; then
            rm -f "$dest"
            error "Downloaded image is not a valid QEMU image: $image_name"
        fi
        
        echo "$dest"
    else
        rm -f "$temp_file"
        error "Failed to download image: $image_name"
    fi
}

create_cloud_init() {
    local vm_dir="$1"
    local username="$2"
    local password="$3"
    local hostname="$4"
    
    local user_data=$(cat <<EOF
#cloud-config
datasource_list: [ NoCloud, None ]
final_message: "CLOUD-INIT-READY"
package_update: false
packages:
  - openssh-server
output:
  all: '| tee -a /var/log/cloud-init-output.log'
users:
  - name: $username
    gecos: $username
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: [sudo]
    shell: /bin/bash
    lock_passwd: false
    plain_text_passwd: '$password'
ssh_pwauth: true
chpasswd:
  list: |
    $username:$password
  expire: false
write_files:
  - path: /etc/ssh/sshd_config.d/50-cloud-init.conf
    owner: root:root
    permissions: '0644'
    content: |
      PasswordAuthentication yes
      PubkeyAuthentication yes
      PermitRootLogin prohibit-password
      UseDNS no
      GSSAPIAuthentication no
runcmd:
  - echo "$username:$password" | chpasswd
  - passwd -u $username
  - systemctl enable ssh
  - systemctl start ssh
EOF
)
    
    local meta_data="{\"instance-id\": \"$hostname\", \"local-hostname\": \"$hostname\"}"
    local seed_iso="$vm_dir/seed.iso"
    
    # Create temporary directory for cloud-init files
    local tmpdir=$(mktemp -d)
    echo "$user_data" > "$tmpdir/user-data"
    echo "$meta_data" > "$tmpdir/meta-data"
    
    # Create ISO using hdiutil
    if hdiutil makehybrid -o "$seed_iso" -hfs -joliet -iso -default-volume-name "cidata" "$tmpdir" >/dev/null 2>&1; then
        rm -rf "$tmpdir"
        echo "$seed_iso"
        return
    fi
    
    # Fallback to mkisofs/genisoimage
    if command -v mkisofs >/dev/null 2>&1; then
        mkisofs -V cidata -o "$seed_iso" -J -r "$tmpdir"
    elif command -v genisoimage >/dev/null 2>&1; then
        genisoimage -V cidata -o "$seed_iso" -J -r "$tmpdir"
    else
        rm -rf "$tmpdir"
        error "Failed to create cloud-init ISO. Install mkisofs or genisoimage"
    fi
    
    rm -rf "$tmpdir"
    echo "$seed_iso"
}

detect_firmware() {
    local arch="${1:-arm64}"
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 doesn't need explicit BIOS path, uses default
        return 0
    fi
    
    # ARM64 firmware candidates
    local candidates=(
        "/opt/homebrew/share/qemu/edk2-aarch64-code.fd"
        "/usr/local/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/qemu/edk2-aarch64-code.fd"
        "/usr/share/edk2/aarch64/QEMU_EFI.fd"
        "/usr/share/AAVMF/AAVMF_CODE.fd"
    )
    
    for firmware in "${candidates[@]}"; do
        if [[ -f "$firmware" ]]; then
            echo "$firmware"
            return
        fi
    done
    
    error "AArch64 UEFI firmware not found. Install with: brew install qemu"
}

wait_for_ssh() {
    local host="$1"
    local port="$2"
    local timeout=120
    local count=0
    
    while [[ $count -lt $timeout ]]; do
        if nc -z "$host" "$port" 2>/dev/null; then
            sleep 2  # Give SSH a moment to be fully ready
            if nc -z "$host" "$port" 2>/dev/null; then
                return 0
            fi
        fi
        sleep 1
        ((count++))
    done
    
    return 1
}

# Image management functions
image_list() {
    echo
    printf "%-20s %-15s %-s\n" "IMAGE" "STATUS" "URL"
    printf "%-20s %-15s %-s\n" "-----" "------" "---"
    
    for image_name in $(get_available_images); do
        for arch in "arm64" "amd64"; do
            local filename="${image_name}-${arch}.qcow2"
            local image_path="$IMAGES_DIR/$filename"
            local status="AVAILABLE"
            
            if [[ -f "$image_path" ]]; then
                local size=$(du -h "$image_path" | cut -f1)
                status="DOWNLOADED ($size)"
            fi
            
            local url
            url=$(get_image_url "$image_name" "$arch")
            printf "%-20s %-15s %-s\n" "${image_name}-${arch}" "$status" "$url"
        done
    done
    echo
}

image_pull() {
    local image_spec="$1"
    [[ -z "$image_spec" ]] && error "Image name is required"
    
    local image_name arch
    
    # Parse image spec (e.g., "debian12-amd64" or "debian12")
    if [[ "$image_spec" =~ ^(.+)-(arm64|amd64)$ ]]; then
        image_name="${BASH_REMATCH[1]}"
        arch="${BASH_REMATCH[2]}"
    else
        image_name="$image_spec"
        arch="arm64"  # Default architecture
    fi
    
    local url
    url=$(get_image_url "$image_name" "$arch")
    if [[ -z "$url" ]]; then
        error "Unknown image: $image_name. Available: $(get_available_images)"
    fi
    
    download_image "$image_name" "$arch" >/dev/null
    log "Image ${image_name}-${arch} downloaded successfully"
}

image_delete() {
    local image_spec="$1"
    local force=false
    
    [[ -z "$image_spec" ]] && error "Image name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local image_name arch
    
    # Parse image spec (e.g., "debian12-amd64" or "debian12")
    if [[ "$image_spec" =~ ^(.+)-(arm64|amd64)$ ]]; then
        image_name="${BASH_REMATCH[1]}"
        arch="${BASH_REMATCH[2]}"
    else
        # If no architecture specified, show error with available options
        error "Please specify architecture. Example: $image_spec-arm64 or $image_spec-amd64"
    fi
    
    local filename="${image_name}-${arch}.qcow2"
    local image_path="$IMAGES_DIR/$filename"
    
    if [[ ! -f "$image_path" ]]; then
        error "Image ${image_name}-${arch} is not downloaded"
    fi
    
    # Note: VMs have their own independent disk copies, so base images can always be deleted
    
    # Confirm deletion
    if [[ "$force" == false ]]; then
        echo "This will permanently delete the downloaded image '${image_name}-${arch}'."
        read -p "Are you sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Deletion cancelled"
            return
        fi
    fi
    
    rm -f "$image_path"
    log "Image ${image_name}-${arch} deleted successfully"
}

# VM management functions
vm_create() {
    local name=""
    local image=""
    local arch="arm64"
    local username="$DEFAULT_USERNAME"
    local password=""
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    local disk="$DEFAULT_DISK"
    local ssh_port=""
    local show_console=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                name="$2"
                shift 2
                ;;
            --image)
                image="$2"
                shift 2
                ;;
            --arch)
                arch="$2"
                shift 2
                ;;
            --user)
                username="$2"
                shift 2
                ;;
            --pass)
                password="$2"
                shift 2
                ;;
            --memory)
                memory="$2"
                shift 2
                ;;
            --cpus)
                cpus="$2"
                shift 2
                ;;
            --disk)
                disk="$2"
                shift 2
                ;;
            --ssh-port)
                ssh_port="$2"
                shift 2
                ;;
            --show-console)
                show_console=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    [[ -z "$name" ]] && error "--name is required"
    [[ -z "$image" ]] && image="debian12"
    
    # Validate architecture
    if [[ "$arch" != "arm64" && "$arch" != "amd64" && "$arch" != "x86_64" ]]; then
        error "Invalid architecture: $arch. Options: arm64, amd64"
    fi
    
    # Normalize architecture
    [[ "$arch" == "x86_64" ]] && arch="amd64"
    
    [[ -z "$password" ]] && password=$(generate_password 16)
    [[ -z "$ssh_port" ]] && ssh_port=$(find_free_port)
    
    local vm_dir="$VMS_DIR/$name"
    
    # Check if VM already exists
    if [[ -d "$vm_dir" ]]; then
        local info_file="$vm_dir/info.json"
        if [[ -f "$info_file" ]]; then
            log "VM '$name' already exists. Checking if it's running..."
            local pid_file="$vm_dir/qemu.pid"
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file" 2>/dev/null)
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    local existing_port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
                    local existing_user=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
                    local existing_pass=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
                    error "VM '$name' is already running on port $existing_port (user: $existing_user, pass: $existing_pass)"
                fi
            fi
            log "VM directory exists but VM is not running. Recreating..."
        fi
    fi
    
    mkdir -p "$vm_dir"
    
    log "Creating VM: $name"
    
    # Download base image
    local base_image
    base_image=$(download_image "$image" "$arch")
    
    # Create VM disk
    local vm_disk="$vm_dir/disk.qcow2"
    if [[ ! -f "$vm_disk" ]]; then
        log "Creating VM disk from base image..." >&2
        if qemu-img convert -O qcow2 "$base_image" "$vm_disk"; then
            if qemu-img resize "$vm_disk" "$disk" >/dev/null; then
                # Sync to ensure VM disk is written to disk
                sync
                # Verify the VM disk is valid
                if ! qemu-img info "$vm_disk" >/dev/null 2>&1; then
                    rm -f "$vm_disk"
                    error "Failed to create valid VM disk for: $name"
                fi
                log "VM disk created successfully" >&2
            else
                rm -f "$vm_disk"
                error "Failed to resize VM disk for: $name"
            fi
        else
            rm -f "$vm_disk"
            error "Failed to create VM disk from base image for: $name"
        fi
    fi
    
    # Create cloud-init seed
    local seed_iso
    seed_iso=$(create_cloud_init "$vm_dir" "$username" "$password" "$name")
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Save VM info
    local info_json="$vm_dir/info.json"
    cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$image",
  "username": "$username",
  "password": "$password",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
    
    # Build QEMU command based on architecture
    local qemu_args=()
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 configuration
        qemu_args=(
            "qemu-system-x86_64"
            "-machine" "q35"
            "-cpu" "qemu64"
            "-m" "$memory"
            "-smp" "$cpus"
            "-object" "memory-backend-ram,id=mem,size=$memory"
            "-numa" "node,memdev=mem"
            "-name" "$name"
            "-device" "virtio-net-pci,netdev=n0"
            "-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
            "-device" "virtio-rng-pci"
            "-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2"
        )
    else
        # ARM64 configuration
        qemu_args=(
            "qemu-system-aarch64"
            "-machine" "virt"
            "-cpu" "max"
            "-bios" "$firmware"
            "-m" "$memory"
            "-smp" "$cpus"
            "-name" "$name"
            "-device" "virtio-net-pci,netdev=n0"
            "-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
            "-device" "virtio-rng-pci"
            "-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2"
        )
    fi
    
    # Add cloud-init for first boot only
    local first_boot_marker="$vm_dir/.first_boot_complete"
    qemu_args+=("-cdrom" "$seed_iso")
    
    # Add acceleration if available (only for ARM64 on macOS)
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        log "Starting VM with console (Ctrl+A then X to quit)"
        log "Credentials: $username / $password"
        log "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        read -p "Press Enter to start..."
        exec "${qemu_args[@]}"
    else
        local console_log="$vm_dir/console.log"
        local pid_file="$vm_dir/qemu.pid"
        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "none"
            "-pidfile" "$pid_file"
        )
        
        # Try to start QEMU, with retry logic for port conflicts
        local max_retries=5
        local retry_count=0
        
        while [[ $retry_count -lt $max_retries ]]; do
            if "${qemu_args[@]}" 2>/dev/null; then
                break
            else
                local qemu_error=$?
                log "QEMU failed to start (exit code: $qemu_error)"
                
                # Check if it's likely a port conflict
                retry_count=$((retry_count + 1))
                if [[ $retry_count -lt $max_retries ]]; then
                    log "Attempting retry $retry_count/$max_retries with a different port..."
                    
                    # Find a new port
                    ssh_port=$(find_free_port)
                    log "Trying new SSH port: $ssh_port"
                    
                    # Update the QEMU args with new port
                    for i in "${!qemu_args[@]}"; do
                        if [[ "${qemu_args[i]}" =~ ^user,id=n0,hostfwd=tcp:127\.0\.0\.1:[0-9]+-:22$ ]]; then
                            qemu_args[i]="user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
                            break
                        fi
                    done
                    
                    # Update the info JSON
                    cat > "$info_json" <<EOF
{
  "name": "$name",
  "arch": "$arch",
  "image": "$image",
  "username": "$username",
  "password": "$password",
  "ssh": {
    "host": "127.0.0.1",
    "port": $ssh_port
  }
}
EOF
                    
                    sleep 1
                else
                    error "Failed to start QEMU after $max_retries attempts"
                fi
            fi
        done
        
        # Wait for SSH
        if wait_for_ssh "127.0.0.1" "$ssh_port"; then
            # Mark first boot as complete after successful SSH connection
            touch "$first_boot_marker"
            log "VM $name is ready, just wait some second to ssh service to be available!"
            echo
            echo "Connect with: ssh $username@127.0.0.1 -p $ssh_port"
            echo "Password: $password"
            #echo "Console log: $console_log"
        else
            log "VM started but SSH is not responding"
            #echo "Check console log: $console_log"
        fi
    fi
}

vm_list() {
    if [[ ! -d "$VMS_DIR" ]]; then
        log "No VMs found (VMs directory doesn't exist)"
        return
    fi
    
    local vm_count=0
    echo
    printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "NAME" "STATUS" "ARCH" "IMAGE" "SSH" "CREDENTIALS"
    printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "----" "------" "----" "-----" "---" "-----------"
    
    for vm_dir in "$VMS_DIR"/*; do
        if [[ ! -d "$vm_dir" ]]; then
            continue
        fi
        
        local vm_name=$(basename "$vm_dir")
        local info_file="$vm_dir/info.json"
        local pid_file="$vm_dir/qemu.pid"
        
        if [[ ! -f "$info_file" ]]; then
            printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "$vm_name" "BROKEN" "-" "-" "-" "-"
            ((vm_count++))
            continue
        fi
        
        local status="STOPPED"
        local ssh_info="-"
        local credentials="-"
        
        # Check if VM is running
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                status="RUNNING"
                
                # Extract info from JSON
                local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
                local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
                local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
                
                ssh_info="127.0.0.1:$port"
                credentials="$username:$password"
            else
                # Clean up stale PID file
                rm -f "$pid_file"
            fi
        fi
        
        # Get info from JSON file
        local arch=$(grep -o '"arch": "[^"]*"' "$info_file" | cut -d'"' -f4)
        local image=$(grep -o '"image": "[^"]*"' "$info_file" | cut -d'"' -f4)
        
        printf "%-15s %-10s %-10s %-10s %-15s %-s\n" "$vm_name" "$status" "${arch:-arm64}" "${image:-unknown}" "$ssh_info" "$credentials"
        ((vm_count++))
    done
    
    if [[ $vm_count -eq 0 ]]; then
        echo "No VMs found"
    else
        echo
        echo "Total VMs: $vm_count"
    fi
}

vm_start() {
    local name="$1"
    local show_console=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --show-console)
                show_console=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"
    local info_file="$vm_dir/info.json"
    local pid_file="$vm_dir/qemu.pid"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]] || [[ ! -f "$info_file" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if already running
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            local port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
            local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
            local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
            error "VM '$name' is already running on port $port (user: $username, pass: $password)"
        fi
        # Clean up stale PID file
        rm -f "$pid_file"
    fi
    
    log "Starting VM: $name"
    
    # Extract VM info
    local username=$(grep -o '"username": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local password=$(grep -o '"password": "[^"]*"' "$info_file" | cut -d'"' -f4)
    local ssh_port=$(grep -o '"port": [0-9]*' "$info_file" | cut -d' ' -f2)
    
    # Find a free port if the saved one is in use
    port_check_function() {
        local test_port=$1
        
        # First check with lsof
        if command -v lsof >/dev/null 2>&1; then
            if lsof -i ":$test_port" >/dev/null 2>&1; then
                return 1
            fi
        fi
        
        # Also check with netstat
        if command -v netstat >/dev/null 2>&1; then
            if netstat -an 2>/dev/null | grep -q "\\.$test_port " || netstat -an 2>/dev/null | grep -q ":$test_port "; then
                return 1
            fi
        fi
        
        return 0
    }
    
    if ! port_check_function "$ssh_port"; then
        log "Saved SSH port $ssh_port is in use, finding new port..."
        ssh_port=$(find_free_port)
        log "Using new SSH port: $ssh_port"
        
        # Update info.json with new port
        local temp_json=$(mktemp)
        sed "s/\"port\": [0-9]*/\"port\": $ssh_port/" "$info_file" > "$temp_json"
        mv "$temp_json" "$info_file"
    fi
    
    # Get VM files
    local vm_disk="$vm_dir/disk.qcow2"
    local seed_iso="$vm_dir/seed.iso"
    
    if [[ ! -f "$vm_disk" ]]; then
        error "VM disk not found: $vm_disk"
    fi
    
    # Get architecture from VM info
    local arch=$(grep -o '"arch": "[^"]*"' "$info_file" | cut -d'"' -f4)
    [[ -z "$arch" ]] && arch="arm64"  # Default to arm64 for backward compatibility
    
    # Detect firmware for ARM64
    local firmware=""
    if [[ "$arch" == "arm64" ]]; then
        firmware=$(detect_firmware "$arch")
    fi
    
    # Build QEMU command based on architecture
    local qemu_args=()
    
    if [[ "$arch" == "amd64" ]]; then
        # x86_64 configuration
        qemu_args=(
            "qemu-system-x86_64"
            "-machine" "q35"
            "-cpu" "qemu64"
            "-m" "2G"
            "-smp" "2"
            "-object" "memory-backend-ram,id=mem,size=2G"
            "-numa" "node,memdev=mem"
            "-name" "$name"
            "-device" "virtio-net-pci,netdev=n0"
            "-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
            "-device" "virtio-rng-pci"
            "-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2"
        )
    else
        # ARM64 configuration
        qemu_args=(
            "qemu-system-aarch64"
            "-machine" "virt"
            "-cpu" "max"
            "-bios" "$firmware"
            "-m" "2G"
            "-smp" "2"
            "-name" "$name"
            "-device" "virtio-net-pci,netdev=n0"
            "-netdev" "user,id=n0,hostfwd=tcp:127.0.0.1:$ssh_port-:22"
            "-device" "virtio-rng-pci"
            "-drive" "file=$vm_disk,if=virtio,cache=writeback,format=qcow2"
        )
    fi
    
    # Only add cloud-init for fresh VMs (check if this is first boot)
    # We determine this by checking if the VM has been booted before
    local first_boot_marker="$vm_dir/.first_boot_complete"
    if [[ -f "$seed_iso" ]] && [[ ! -f "$first_boot_marker" ]]; then
        qemu_args+=("-cdrom" "$seed_iso")
    fi
    
    # Add acceleration if available (only for ARM64 on macOS)
    if [[ "$OSTYPE" == "darwin"* && "$arch" == "arm64" ]]; then
        qemu_args+=("-accel" "hvf")
    fi
    
    # Add console/display options
    if [[ "$show_console" == true ]]; then
        qemu_args+=("-nographic" "-serial" "mon:stdio" "-monitor" "none")
        log "Starting VM with console (Ctrl+A then X to quit)"
        log "Credentials: $username / $password"
        log "SSH command: ssh $username@127.0.0.1 -p $ssh_port"
        read -p "Press Enter to start..."
        exec "${qemu_args[@]}"
    else
        local console_log="$vm_dir/console.log"
        qemu_args+=(
            "-daemonize"
            "-display" "none"
            "-serial" "file:$console_log"
            "-monitor" "none"
            "-pidfile" "$pid_file"
        )
        
        if "${qemu_args[@]}" 2>/dev/null; then
            if wait_for_ssh "127.0.0.1" "$ssh_port"; then
                # Mark first boot as complete after successful SSH connection (if it was first boot)
                if [[ ! -f "$first_boot_marker" ]]; then
                    touch "$first_boot_marker"
                fi
                log "VM is ready!"
                echo
                echo "Connect with: ssh $username@127.0.0.1 -p $ssh_port"
                echo "Password: $password"
                echo "Console log: $console_log"
            else
                log "VM started but SSH is not responding"
                echo "Check console log: $console_log"
            fi
        else
            error "Failed to start VM"
        fi
    fi
}

vm_stop() {
    local name="$1"
    
    [[ -z "$name" ]] && error "VM name is required"
    
    local vm_dir="$VMS_DIR/$name"
    local pid_file="$vm_dir/qemu.pid"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if VM is running
    if [[ ! -f "$pid_file" ]]; then
        log "VM '$name' is not running"
        return
    fi
    
    local pid=$(cat "$pid_file" 2>/dev/null)
    if [[ -z "$pid" ]] || ! kill -0 "$pid" 2>/dev/null; then
        log "VM '$name' is not running (cleaning up stale PID file)"
        rm -f "$pid_file"
        return
    fi
    
    log "Stopping VM: $name (PID: $pid)"
    
    # Try graceful shutdown first
    if kill -TERM "$pid" 2>/dev/null; then
        local count=0
        local timeout=30
        
        log "Sending graceful shutdown signal..."
        while [[ $count -lt $timeout ]] && kill -0 "$pid" 2>/dev/null; do
            sleep 1
            ((count++))
        done
        
        if kill -0 "$pid" 2>/dev/null; then
            log "Graceful shutdown timed out, forcing stop..."
            kill -KILL "$pid" 2>/dev/null
            sleep 2
        fi
        
        if ! kill -0 "$pid" 2>/dev/null; then
            log "VM stopped successfully"
            rm -f "$pid_file"
        else
            error "Failed to stop VM"
        fi
    else
        error "Failed to send stop signal to VM"
    fi
}

vm_delete() {
    local name="$1"
    local force=false
    
    [[ -z "$name" ]] && error "VM name is required"
    
    # Parse remaining arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    local vm_dir="$VMS_DIR/$name"
    
    # Check if VM exists
    if [[ ! -d "$vm_dir" ]]; then
        error "VM '$name' does not exist"
    fi
    
    # Check if VM is running and stop it
    local pid_file="$vm_dir/qemu.pid"
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log "Stopping running VM before deletion..."
            vm_stop "$name"
        fi
    fi
    
    # Confirm deletion
    if [[ "$force" == false ]]; then
        echo "This will permanently delete VM '$name' and all its data."
        read -p "Are you sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Deletion cancelled"
            return
        fi
    fi
    
    log "Deleting VM: $name"
    rm -rf "$vm_dir"
    log "VM '$name' deleted successfully"
}

purge() {
    local force=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force)
                force=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done
    
    # Count what will be deleted
    local vm_count=0
    local image_count=0
    
    # Count VMs
    if [[ -d "$VMS_DIR" ]]; then
        for vm_dir in "$VMS_DIR"/*; do
            if [[ -d "$vm_dir" ]]; then
                ((vm_count++))
            fi
        done
    fi
    
    # Count downloaded images
    if [[ -d "$IMAGES_DIR" ]]; then
        for image_file in "$IMAGES_DIR"/*.qcow2; do
            if [[ -f "$image_file" ]]; then
                ((image_count++))
            fi
        done
    fi
    
    # Show what will be deleted
    if [[ $vm_count -eq 0 && $image_count -eq 0 ]]; then
        log "Nothing to purge - no VMs or downloaded images found"
        return
    fi
    
    log "Purge will delete:"
    [[ $vm_count -gt 0 ]] && log "  - $vm_count VM(s) and their data"
    [[ $image_count -gt 0 ]] && log "  - $image_count downloaded image(s)"
    
    # Confirm purge
    if [[ "$force" == false ]]; then
        echo
        echo "WARNING: This will permanently delete ALL VMs and downloaded images!"
        echo "This action cannot be undone."
        read -p "Are you absolutely sure? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log "Purge cancelled"
            return
        fi
    fi
    
    log "Starting purge operation..."
    
    # Stop and delete all VMs
    if [[ $vm_count -gt 0 ]]; then
        log "Deleting $vm_count VMs..."
        for vm_dir in "$VMS_DIR"/*; do
            if [[ -d "$vm_dir" ]]; then
                local vm_name=$(basename "$vm_dir")
                log "  Deleting VM: $vm_name"
                
                # Stop VM if running
                local pid_file="$vm_dir/qemu.pid"
                if [[ -f "$pid_file" ]]; then
                    local pid=$(cat "$pid_file" 2>/dev/null)
                    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                        log "    Stopping running VM..."
                        kill -TERM "$pid" 2>/dev/null || true
                        sleep 2
                        kill -KILL "$pid" 2>/dev/null || true
                    fi
                fi
                
                # Delete VM directory
                rm -rf "$vm_dir"
            fi
        done
        
        # Remove empty VMs directory
        [[ -d "$VMS_DIR" && -z "$(ls -A "$VMS_DIR" 2>/dev/null)" ]] && rmdir "$VMS_DIR"
    fi
    
    # Delete all downloaded images
    if [[ $image_count -gt 0 ]]; then
        log "Deleting $image_count downloaded images..."
        for image_file in "$IMAGES_DIR"/*.qcow2; do
            if [[ -f "$image_file" ]]; then
                local image_name=$(basename "$image_file")
                log "  Deleting image: $image_name"
                rm -f "$image_file"
            fi
        done
        
        # Remove empty images directory
        [[ -d "$IMAGES_DIR" && -z "$(ls -A "$IMAGES_DIR" 2>/dev/null)" ]] && rmdir "$IMAGES_DIR"
    fi
    
    # Remove empty root directory if both subdirs are gone
    if [[ -d "$WORK_ROOT" && -z "$(ls -A "$WORK_ROOT" 2>/dev/null)" ]]; then
        rmdir "$WORK_ROOT"
    fi
    
    log "Purge completed successfully!"
    log "Deleted $vm_count VM(s) and $image_count image(s)"
}

vm_help() {
    cat <<EOF
VM Commands Help:

USAGE:
    $0 vm COMMAND [options]

COMMANDS:
    create              Create and start a new VM
    list                List all VMs and their status
    start VM_NAME       Start an existing VM
    stop VM_NAME        Stop a running VM  
    delete VM_NAME      Delete a VM and its files
    help                Show this help message

CREATE OPTIONS:
    --name NAME         VM name (required)
    --image IMAGE       Base image (default: debian12)
    --arch ARCH         Architecture: arm64, amd64 (default: arm64)
    --user USERNAME     Username (default: $DEFAULT_USERNAME)
    --pass PASSWORD     Password (default: auto-generated)
    --memory SIZE       Memory size (default: $DEFAULT_MEMORY)
    --cpus COUNT        CPU count (default: $DEFAULT_CPUS)
    --disk SIZE         Disk size (default: $DEFAULT_DISK)
    --ssh-port PORT     SSH port (default: auto-assign)
    --show-console      Show console output

START OPTIONS:
    --show-console      Show console output

DELETE OPTIONS:
    --force             Delete without confirmation

EXAMPLES:
    $0 vm create --name myvm
    $0 vm create --name myvm --arch amd64 --memory 4G --cpus 4
    $0 vm create --name myvm --image debian12 --user admin --pass mypass
    $0 vm list
    $0 vm start myvm
    $0 vm start myvm --show-console
    $0 vm stop myvm
    $0 vm delete myvm
    $0 vm delete myvm --force

NOTES:
    - VMs have independent disk copies, so deleting base images won't affect running VMs
    - ARM64 VMs use HVF acceleration on macOS, x86_64 VMs run in emulation mode
    - SSH credentials are shown after VM creation and in 'vm list' output
EOF
}

image_help() {
    cat <<EOF
Image Commands Help:

USAGE:
    $0 image COMMAND [options]

COMMANDS:
    list                List available and downloaded images
    pull IMAGE_NAME     Download an image
    delete IMAGE_NAME   Delete a downloaded image  
    help                Show this help message

AVAILABLE IMAGES:
    debian12-arm64      Debian 12 for ARM64 architecture
    debian12-amd64      Debian 12 for x86_64 architecture

DELETE OPTIONS:
    --force             Delete without confirmation

EXAMPLES:
    $0 image list
    $0 image pull debian12-arm64
    $0 image pull debian12-amd64
    $0 image delete debian12-arm64
    $0 image delete debian12-amd64 --force

NOTES:
    - Images are downloaded to ~/.linux_vm_cli/images/
    - Each VM creates its own independent disk copy from base images
    - Base images can be safely deleted after VM creation to save space
    - Images are automatically downloaded when creating VMs if not present
EOF
}

main() {
    local entity="${1:-}"
    local command="${2:-}"
    
    case "$entity" in
        vm)
            shift
            [[ $# -gt 0 ]] && shift
            case "$command" in
                create)
                    check_dependencies
                    mkdir -p "$IMAGES_DIR" "$VMS_DIR"
                    vm_create "$@"
                    ;;
                list)
                    mkdir -p "$VMS_DIR"
                    vm_list
                    ;;
                start)
                    check_dependencies
                    vm_start "$@"
                    ;;
                stop)
                    vm_stop "$@"
                    ;;
                delete)
                    vm_delete "$@"
                    ;;
                help|--help|-h|"")
                    vm_help
                    ;;
                *)
                    error "Unknown VM command: $command"
                    ;;
            esac
            ;;
        image)
            shift
            [[ $# -gt 0 ]] && shift
            case "$command" in
                list)
                    mkdir -p "$IMAGES_DIR"
                    image_list
                    ;;
                pull)
                    check_dependencies
                    mkdir -p "$IMAGES_DIR"
                    image_pull "$@"
                    ;;
                delete)
                    image_delete "$@"
                    ;;
                help|--help|-h|"")
                    image_help
                    ;;
                *)
                    error "Unknown image command: $command"
                    ;;
            esac
            ;;
        purge)
            shift 1
            purge "$@"
            ;;
        --help|-h|help|"")
            usage
            ;;
        *)
            error "Unknown entity: $entity"
            ;;
    esac
}

main "$@"